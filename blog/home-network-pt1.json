{"date":"2020-06-14","title":"Building A Home Lab With Podman - Pt1","desc":"Learn how Podman can be used to create a home lab newtork and name resolution.","file":"home-network-pt1","html":"<h1>Building A Home Lab With Podman - Pt1</h1>\n<p><em>Checkout <a href=\"/blog/home-network-pt2\">Part 2</a> For Application Routing</em></p>\n<p>It's common to set up a network, a few virtual hosts, and fundamental network services at home as a way to learn how these technologies interact.</p>\n<p>While moving apartments in Brooklyn I discovered a Thinkpad laptop just collecting dust.\nThe laptop had good specs and a 1TB ssd.\nI wanted to put this bad boy to use.</p>\n<p>Soon the idea of creating a modern lab based on containers, free of noisy and expensive equipment, took hold.</p>\n<p>This post introduces network topology, components which make up the network, and how name resolution is achieved.</p>\n<h2>The Stack</h2>\n<ul>\n<li>Podman - a daemonless container runtime that works well with SystemD</li>\n<li>CoreDNS - a DNS server that uses a ton of plugins to implement name resolution.</li>\n<li>NetData - a C monitoring daemon which scrapes /proc for every metric you can think of.</li>\n<li>Traefik - a service routing solution which supports path routing, redirects, and load balancing.</li>\n<li>Fedora32 - good ol' fedora linux as a host operating system (shameless plug).</li>\n</ul>\n<p>Above is the software stack used in the lab.</p>\n<h2>The Network</h2>\n<p>A typical home network consists of a modem, a router with a built in switch and WiFi, and devices which connect to a local LAN.\nThis lab will introduce an additional host for creating and exposing containers.</p>\n<pre class=\"hljs\"><code>+----------+  +--------+\n|  Laptop  |  | Iphone |\n+-----+----+  +---+----+\n      |           |\n      |           |\n      |           |\n      |           |\n+-----+-----------+----+                    +------------------------------+\n|                      |                    |                              |\n| LAN 192.168.185.0/24 |                    |  CONTAINER-LAN 10.89.0.0/24  |\n|                      |                    |                              |\n+---------+------------+                    +-------+----------------------+\n          |                                         |\n          |                                         |\n          | port forward +-----------+              |\n          +--------------+ CONTAINER +--------------+\n          |              +-----^-----+              |\n          |                    | podman run         |\n          |              +-----+-----+              |\n          |              |           |              |\n          +--------------+  CT-HOST  +--------------+\n                         |           |\n                         +-----------+\n</code></pre>\n<p>The network will look like this.</p>\n<p>CT-HOST is a Fedora32 laptop running Podman and will manage container lifecycles.\nThe host resides on two networks: LAN (192.168.185.0/24) where devices communicate and CONTAINER-LAN (10.89.0.0/24) where containers communicate.\nThe CONTAINER-LAN is virtual and created by the linux kernel.</p>\n<p>Containers may be exposed on &quot;ct-host&quot; to devices on LAN by port-forwarding the container's port onto the hosts.\nNot every container needs to have their ports forwarded but to achieve name resolution this is required.</p>\n<h2>Name Resolution</h2>\n<p>Name resolution provides mapping from a hostname to a service.\nThis is encountered every time &quot;www.google.com&quot; is typed into a browser.\nThe name &quot;www.google.com&quot; is resolved to an IP address where web servers provide this service.\nThis lab creates the <code>ldelossa.net</code> local domain.</p>\n<p>Personally, I don't want to write RFC 1035 zone files, host ancient bind servers, or deal with cryptic configs.\nThere is a certain beauty in the syntax of a hosts file.\nA simple text file which maps a hostname to an IP address suits my needs well.\nThe answer was found in <a href=\"https://coredns.io/\">CoreDNS</a> and its <a href=\"https://coredns.io/plugins/hosts/\">hosts</a> plugin.</p>\n<p>On top of a terse syntax the &quot;hosts&quot; plugin provides dynamic reloading.\nChanges to the file holding your hostname mappings will reload the server, the changes taking effect soon after.</p>\n<h3>Podman</h3>\n<p>Podman is the container runtime used in this lab.</p>\n<p>Podman and Systemd play along nicely.\nSystemd services can be generated directly from Podman.\nThese service files can be used to start the container on boot, restart it on failure, create dependencies between containers, or other facilities Systemd offers.</p>\n<h3>CoreDNS Container</h3>\n<p>configuration:</p>\n<pre class=\"hljs\"><code><span class=\"hljs-meta\">$</span><span class=\"bash\"> cat Corefile</span>\n.:53 {\n  cache 10\n  forward . 8.8.8.8 9.9.9.9\n  log\n  errors\n}\n\nldelossa.net {\n  cache 10\n  hosts /etc/coredns/hosts {\n  }\n}\n<span class=\"hljs-meta\">$</span><span class=\"bash\"> cat hosts</span>\n192.168.185.10 traefik.ldelossa.net\n192.168.185.10 ct-host.ldelossa.net\n192.168.185.10 prom.ldelossa.net\n</code></pre>\n<p>CoreDNS with the host plugin uses two configuration files: &quot;Corefile&quot; and &quot;hosts&quot; file.</p>\n<p>The &quot;Corefile&quot; configures Coredns to forward requests not destined for <code>ldelossa.net</code> to Google's DNS and cache the results for a bit.\nAny requests for <code>ldelossa.net</code> are forwarded to the &quot;hosts&quot; plugin, using the file <code>/etc/coredns/hosts</code>.</p>\n<p>The &quot;hosts&quot; defines hostname mappings.\nFor each entry in this file Coredns will return an A record mapping the hostname to the IP address.</p>\n<pre class=\"hljs\"><code><span class=\"hljs-meta\">$</span><span class=\"bash\"> podman create --network ct-host --name coredns -dt -p 192.168.185.10:53:53/tcp -p 192.168.185.10:53:53/udp -v /etc/containers/etc.d/coredns:/etc/coredns coredns/coredns -conf /etc/coredns/Corefile</span>\n</code></pre>\n<p>Above shows the podman command used to create the container.</p>\n<p>A few things to note</p>\n<ul>\n<li>Port 53(udp/tcp) is exposed to other devices on LAN via port-forwarding</li>\n<li>Configuration files are mapped from <code>/etc/containers/etc.d/coredns</code> to <code>/etc/coredns</code> inside the container.</li>\n<li>Editing the &quot;hosts&quot; file on &quot;ct-host&quot; will reload Coredns without having to restart the container.</li>\n</ul>\n<pre class=\"hljs\"><code><span class=\"hljs-meta\">$</span><span class=\"bash\"> podman generate systemd --name coredns &gt; /etc/systemd/system/coredns-container.service</span>\n<span class=\"hljs-meta\">$</span><span class=\"bash\"> systemctl daemon-reload</span>\n<span class=\"hljs-meta\">$</span><span class=\"bash\"> systemctl <span class=\"hljs-built_in\">enable</span> coredns-container</span>\n<span class=\"hljs-meta\">$</span><span class=\"bash\"> systemctl start coredns-container</span>\n</code></pre>\n<p>A SystemD service can be generated and enabled with the commands above.</p>\n<h3>Configuring Devices</h3>\n<p>A typical approach to configuring devices to utilize a custom DNS server would be DHCP.\nUnfortunately my router does not allow the configuration of DHCP (poo-poo to you ampliFi).\nHowever, devices can &quot;opt-in&quot; by setting their DNS server to <code>192.168.185.10:53</code>.</p>\n<p>As new services come onto the network simply editing <code>/etc/containers/etc.d/coredns/hosts</code> on &quot;ct-host&quot; will provide immediate resolution for devices configured with this DNS.</p>\n<h2>Conclusion</h2>\n<p>Home labs are a great way to learn new technologies.\nBy utilizing Podman and CoreDNS a solution for name resolution was devised.\nMapping configuration files from the host into containers provides a fast and dynamic way to update DNS in the lab.</p>\n<p>In <a href=\"/blog/home-network-pt2\">Part 2</a> a mechanism for routing hostnames to specific containerized services is introduced.</p>\n"}