{"date":"2020-07-16","title":"Sequential Consistency In Practice","desc":"Clarification on sequential consistency and distributed system","file":"sequential-consistency-in-practice","html":"<h1>Sequential Consistency In Practice</h1>\n<p>If you are a software engineer today concurrency is everywhere.</p>\n<p>On the front-end it manifests as asynchronous web requests, the backend as service-to-service communication, and in systems programming as SMP and thread safety.</p>\n<p>With the ubiquity of programming with the 4th dimension in mind it's valuable to expand on the building blocks.</p>\n<p>One of these blocks comes in the form of consistency models: specific rules which govern concurrent access to shared resources.</p>\n<p>With a focus on sequential consistency I'd like to show you how this model is used in practice with distributed systems.</p>\n<h2>Sequential Consistency</h2>\n<p>A conversation with an ex-colleague and friend, centered around the topic, influenced him to write up a nice explanation of sequential consistency.</p>\n<p>You can check out that article <a href=\"http://space.af/blog/2020/07/16/sequential-consistency-described-by-viotti-and-vukolic/\">here</a>, I will expand on it a bit.</p>\n<p>In the article referenced above it's explained that in sequential consistency a processor may view writes of other processors in any interleaving, as long as those interleavings remain in the same order.</p>\n<p>In short recap:</p>\n<pre class=\"hljs\"><code>          Proc-1   Proc-2\n           W(x)     W(y)\n           W(z)\n\n\n  Valid:  W(x),W(z),W(y)\n          W(y),W(x),W(z)\n          W(x),W(y),W(z)\n\nInvalid:  W(z),W(x),W(Y)\n</code></pre>\n<p>The invalid interleaving is such due to Proc-1's writes happening out of Proc-1's program order.</p>\n<h2>Expanding On Sequential Consistency</h2>\n<p>While the provided definition of sequential consistency is easy to follow for two processors it gets a bit more interesting when we model a distributed system.</p>\n<p>In our distributed system two processes will be issuing writes to a shared register and two other processes will be observing those writes and then issuing a read.</p>\n<p>Each process is to obey sequential consistency.</p>\n<pre class=\"hljs\"><code>          Proc-1      Proc-2\n           W(x)        W(y)\n           W(z)\n\n\n Proc-3 Observes: W(x),W(z),W(y), R() =&gt; y\n\n Proc-4 Observes: W(y),W(x),W(z), R() =&gt; z\n</code></pre>\n<p>Here we notice that Proc-3 and Proc-4 do not agree on the shared register's value, yet this is legal in sequential consistency.</p>\n<p>As you can imagine, in practice this is not the desired behavior.</p>\n<h2>Sequential Consistency In Practice</h2>\n<p>In order for sequential consistency to be useful in a distributed system another mechanism must be provided to ensure all processes see the <strong>same</strong> interleaving of operations.</p>\n<p>A slide from Martin Kleppmann's great <a href=\"https://www.youtube.com/watch?v=D5iCl12MuRw&amp;feature=youtu.be\">talk</a> provides one such mechanism.</p>\n<p><img src=\"/martin-klepmann-sequential-consistency.png\" alt=\"async writes in sequential system\"></p>\n<ol>\n<li>Martin Kleppmann on “Sequential Consistency versus Linearizability”</li>\n</ol>\n<p>This slide shows that all writes are fed through a &quot;transaction processor&quot; to create one consistent interleaving of sequential operations.</p>\n<p>Due to network delay each processor may &quot;lag&quot; behind, seeing older or newer writes then the others.</p>\n<p>However each processor will <strong>always</strong> observe a totally ordered sequential list of operations.</p>\n<p>Therefore per the consistency model:</p>\n<ul>\n<li>the second processor may read the N-1 write until the network delivers write N.</li>\n<li>no processor who has received write N will read write N-1.</li>\n<li>every process will observe a sequentially consistent total ordered history of operations.</li>\n</ul>\n<h2>In Conclusion</h2>\n<p>In the practice of designing distributed systems sequential consistency requires some mechanism to obtain a consistent read of a shared register across processes.</p>\n<p>When &quot;sequential consistency&quot; is mentioned in regards to a distributed system what is usually being expressed is the ability for processors to &quot;lag&quot; behind observing changes, but eventually seeing all changes in a well defined total order.</p>\n<p>A secondary mechanism, whether a dedicated process, vector clocks, or fence id, must be present to enforce that each process sees a totally ordered sequence of events.</p>\n<hr>\n<p>edits:</p>\n<ul>\n<li>fix on valid sequential interleavings in first example.</li>\n</ul>\n"}