<!doctype html> <html lang=en> <head> <meta charset=utf-8> <meta content="width=device-width,initial-scale=1" name=viewport> <meta content=#333333 name=theme-color> <base href=/ > <link href=global.css rel=stylesheet> <link href=manifest.json rel=manifest crossorigin=use-credentials> <link href=favicon.png rel=icon type=image/png> <link href=https://meyerweb.com/eric/tools/css/reset/reset.css rel=stylesheet> <link href="https://fonts.googleapis.com/css2?family=Baloo+Paaji+2:wght@500&display=swap" rel=stylesheet> <link href="https://fonts.googleapis.com/css2?family=Source+Code+Pro&display=swap" rel=stylesheet> <link href="https://fonts.googleapis.com/css2?family=Muli&display=swap" rel=stylesheet> <link href=github-markdown.css rel=stylesheet> <link href=//cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/zenburn.min.css rel=stylesheet> <script src=//cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js></script> <script src=//gc.zgo.at/count.js async data-goatcounter=https://ldelossa.goatcounter.com/count></script> <style>.layout.svelte-lybuj1{display:grid;height:100vh;width:100vw;grid-template-columns:1.5fr 6fr}.content-wrapper.svelte-lybuj1{grid-area:1/2/2/3;overflow-y:auto}.content-wrapper-full.svelte-lybuj1{grid-area:1/1/2/3}@media screen and (max-width:600px){.layout.svelte-lybuj1{display:grid;grid-template-columns:1fr}.content-wrapper.svelte-lybuj1{z-index:1}.content-wrapper-full.svelte-lybuj1{z-index:1}}.sidebar-open.svelte-posnvr{display:flex;justify-content:space-between;flex-direction:column;height:100vh;max-width:300px;min-width:275px;margin-right:1vmin;background:#4b6777;overflow-y:hidden}.sidebar-closed.svelte-posnvr{display:none}.sb-toggle-button-open.svelte-posnvr{z-index:100;outline:0;background-color:Transparent;border:none;padding:10px 12px;font-size:30px;cursor:pointer;color:#f3f8f2;font-family:Muli,cursive;position:fixed;left:0}.sb-toggle-button-open.svelte-posnvr:hover{color:#f2511b}.sb-toggle-button-closed.svelte-posnvr{z-index:100;outline:0;background-color:Transparent;border:none;padding:10px 12px;font-size:30px;cursor:pointer;color:#4b6777;font-family:Muli,cursive;position:fixed;left:0}.sb-toggle-button-closed.svelte-posnvr:hover{color:#f2511b}.author-wrapper.svelte-posnvr{display:flex;flex-direction:column;justify-content:center;margin:40px}.author.svelte-posnvr{text-align:center;font-size:2rem;color:#f3f8f2;font-family:Muli,sans-serif;letter-spacing:1px;text-shadow:2px 2px 0 rgba(0,0,0,.35),2px 2px 5px rgba(0,0,0,.5)}.console-wrapper.svelte-posnvr{display:flex;margin:20px;justify-content:center}nav.svelte-posnvr{display:flex;flex-direction:column;justify-content:space-around;flex-wrap:wrap}.icons-wrapper.svelte-posnvr{display:flex;flex-direction:column;justify-content:flex-end;padding:20px}@media screen and (max-width:600px){.sidebar-open.svelte-posnvr{-moz-box-shadow:initial;-webkit-box-shadow:initial;box-shadow:initial;max-width:initial;min-width:initial;margin-right:initial;border-right:initial;height:100vh;width:100vw}.icons-wrapper.svelte-posnvr{display:flex;grid-area:icons;flex-direction:column;justify-content:space-between}}pre.svelte-wc9ma6 code.svelte-wc9ma6{border-radius:3%;padding:8px;display:block;min-width:230px;max-width:275px;background:#333;color:#737373}.button-wrapper.svelte-n868dk{text-align:center;margin:1rem 0 1rem 0;padding:1rem 1rem 1rem 1rem}.button-ref.svelte-n868dk{text-decoration:underline;font-size:30px;color:#e9f1f7;font-family:Muli,sans-serif;letter-spacing:1px;text-shadow:2px 2px 0 rgba(0,0,0,.35),2px 2px 5px rgba(0,0,0,.5)}.button-ref.svelte-n868dk:hover{color:#f2511b;text-shadow:-1px -1px 0 rgba(242,81,27,.5),-1px -1px -5px rgba(242,81,27,.5)}.icons.svelte-13lfieo{display:flex;flex-direction:row;justify-content:space-around;flex-wrap:wrap}img.svelte-13lfieo{width:30px;height:30px}img.svelte-13lfieo:hover{-webkit-filter:drop-shadow(2px 2px 2px #222);filter:drop-shadow(2px 2px 2px #222)}.blog-wrapper.svelte-1ih628r{max-height:100vh;max-width:100vw}.markdown-body.svelte-1ih628r{min-width:100px;max-width:900px;margin:0 auto;padding:45px;color:#e9f1f7;font-family:Muli,sans-serif}@media(max-width:767px){.markdown-body.svelte-1ih628r{max-width:75%}}</style> <noscript id=sapper-head-start></noscript><title>The Good With The Bad: Go's net/url.URL and JSON</title><noscript id=sapper-head-end></noscript> <link href=/client/21d5f7fc0374dd879b15/main.js rel=preload as=script><link href=/client/21d5f7fc0374dd879b15/blog_$slug.2.js rel=preload as=script></head> <body> <div id=sapper> <div class="svelte-lybuj1 layout"><button class="svelte-posnvr sb-toggle-button-closed">☰</button> <div class="svelte-posnvr sidebar-closed"><div class="svelte-posnvr author-wrapper"><p class="svelte-posnvr author">Louis DeLosSantos<p><div class="svelte-posnvr console-wrapper"><pre class=svelte-wc9ma6><code class=svelte-wc9ma6>❯ tree ./ldelossa 
├── hardware
├── linux
├── music
└── software
❯ <span id=cursor>▊</span></code></pre></div></div> <nav class=svelte-posnvr><div class="svelte-n868dk button-wrapper"><a href=about class="svelte-n868dk button-ref">about</a></div> <div class="svelte-n868dk button-wrapper"><a href=resume class="svelte-n868dk button-ref">resume</a></div> <div class="svelte-n868dk button-wrapper"><a href=projects class="svelte-n868dk button-ref">projects</a></div> <div class="svelte-n868dk button-wrapper"><a href=blog class="svelte-n868dk button-ref">blog</a></div></nav> <div class="svelte-posnvr icons-wrapper"><div class="svelte-13lfieo icons"><a href=https://www.linkedin.com/in/louisdelossantos/ target=_blank><img alt="linkedin icon" class=svelte-13lfieo src=linkedin.svg></a> <a href=https://github.com/ldelossa target=_blank><img alt="github icon" class=svelte-13lfieo src=github.svg></a> <a href=https://twitter.com/ldelossa_ld target=_blank><img alt="twitter icon" class=svelte-13lfieo src=twitter.svg></a></div></div></div> <div class="svelte-lybuj1 content-wrapper-full"> <div class="svelte-1ih628r blog-wrapper"><article class="svelte-1ih628r markdown-body"><h1>The Good With The Bad: Go's net/url.URL and JSON</h1> <p>A rather common task presented itself while working on <a href=https://github.com/quay/clair>Clair</a> this week.</p> <p>A URL needed to be generated in one service and communicated to another one. Like most would, JSON was to be used as the encoding and HTTP as the transport mechanism. A common task in most languages but a caveat exists in Go.</p> <p>Logically a net/url.URL would be encoded as a string and transported in JSON as such data type. Looking at the net/url.URL source code we see no implementations for json.Marshaler/json.Unmarshaller nor encoding.TextMarshaller/encoding.TextUnmarshaller.</p> <p>It becomes the programmer's responsibility to implement this behavior.</p> <h2>The Solution</h2> <p>Several ways exist to solve the problem. The way chosen in Clair is as follows.</p> <pre class=hljs><code><span class=hljs-comment>// Webhook holds the details for clients to call back the Notifier</span>
<span class=hljs-comment>// and receive notifications.</span>
<span class=hljs-keyword>type</span> Webhook <span class=hljs-keyword>struct</span> {
	NotificationID uuid.UUID <span class=hljs-string>`json:"notification_id"`</span>
	Callback       url.URL   <span class=hljs-string>`json:"callback"`</span>
}

<span class=hljs-function><span class=hljs-keyword>func</span> <span class=hljs-params>(wh Webhook)</span> <span class=hljs-title>MarshalJSON</span><span class=hljs-params>()</span> <span class=hljs-params>([]<span class=hljs-keyword>byte</span>, error)</span></span> {
	<span class=hljs-keyword>var</span> m = <span class=hljs-keyword>map</span>[<span class=hljs-keyword>string</span>]<span class=hljs-keyword>string</span>{
		<span class=hljs-string>"notification_id"</span>: wh.NotificationID.String(),
		<span class=hljs-string>"callback"</span>:        wh.Callback.String(),
	}
	<span class=hljs-keyword>return</span> json.Marshal(m)
}

<span class=hljs-function><span class=hljs-keyword>func</span> <span class=hljs-params>(wh *Webhook)</span> <span class=hljs-title>UnmarshalJSON</span><span class=hljs-params>(b []<span class=hljs-keyword>byte</span>)</span> <span class=hljs-title>error</span></span> {
	<span class=hljs-keyword>var</span> m = <span class=hljs-built_in>make</span>(<span class=hljs-keyword>map</span>[<span class=hljs-keyword>string</span>]<span class=hljs-keyword>string</span>, <span class=hljs-number>2</span>)
	err := json.Unmarshal(b, &m)
	<span class=hljs-keyword>if</span> err != <span class=hljs-literal>nil</span> {
		<span class=hljs-keyword>return</span> err
	}
	<span class=hljs-keyword>if</span> _, ok := m[<span class=hljs-string>"notification_id"</span>]; !ok {
		<span class=hljs-keyword>return</span> fmt.Errorf(<span class=hljs-string>"json unmarshal failed. webhook requires a \"notification_id\" field"</span>)
	}
	<span class=hljs-keyword>if</span> _, ok := m[<span class=hljs-string>"callback"</span>]; !ok {
		<span class=hljs-keyword>return</span> fmt.Errorf(<span class=hljs-string>"json unmarshal failed. webhook requires a \"callback\" field"</span>)
	}

	uid, err := uuid.Parse(m[<span class=hljs-string>"notification_id"</span>])
	<span class=hljs-keyword>if</span> err != <span class=hljs-literal>nil</span> {
		<span class=hljs-keyword>return</span> fmt.Errorf(<span class=hljs-string>"json unmarshal failed. malformed notification uuid: %v"</span>, err)
	}
	cbURL, err := url.Parse(m[<span class=hljs-string>"callback"</span>])
	<span class=hljs-keyword>if</span> err != <span class=hljs-literal>nil</span> {
		<span class=hljs-keyword>return</span> fmt.Errorf(<span class=hljs-string>"json unmarshal failed. malformed callback url: %v"</span>, err)
	}

	(*wh).NotificationID = uid
	(*wh).Callback = *cbURL
	<span class=hljs-keyword>return</span> <span class=hljs-literal>nil</span>
}
</code></pre> <p>Implementing the MarshalJSON and UnmarshalJSON methods for the entire struct was feasible since it's small and maps nicely into a <code>go map[string]string</code> data structure.</p> <p>If the struct were larger or consisted of heterogeneous field types one may decide implementing a custom type is simpler.</p> <p>The downside to the former approach appears in forced type conversions littering the code.</p> <h2>So... Why</h2> <p>An obvious question is likely rattling around your brain right now.</p> <p>Why did the stdlib developers not implement the basic interface methods aligning with the most common use cases?</p> <p>The source code holds a clue:</p> <pre class=hljs><code><span class=hljs-comment>// Marshaling interface implementations.</span>
<span class=hljs-comment>// Would like to implement MarshalText/UnmarshalText but that will change the JSON representation of URLs.</span>

<span class=hljs-function><span class=hljs-keyword>func</span> <span class=hljs-params>(u *URL)</span> <span class=hljs-title>MarshalBinary</span><span class=hljs-params>()</span> <span class=hljs-params>(text []<span class=hljs-keyword>byte</span>, err error)</span></span> {
    <span class=hljs-keyword>return</span> []<span class=hljs-keyword>byte</span>(u.String()), <span class=hljs-literal>nil</span>
}
</code></pre> <p>The reason lies in Go's strict backwards compatibility promise.</p> <p>In a hypothetical, lets say the appropriate marshalling methods were introduced in Go 1.14.</p> <p>Two services exist A and B which communicate a "net/url.URL" structure via JSON/HTTP and no custom marshalling methods were implemented like above.</p> <p>Service A is rebuilt in Go 1.14.</p> <p>When service A receives the "net/url.URL" it will receive json similar to:</p> <pre class=hljs><code>{<span class=hljs-attr>"url"</span>: {<span class=hljs-attr>"Scheme"</span>:<span class=hljs-string>"http"</span>,<span class=hljs-attr>"Opaque"</span>:<span class=hljs-string>""</span>,<span class=hljs-attr>"User"</span>:<span class=hljs-literal>null</span>,<span class=hljs-attr>"Host"</span>:<span class=hljs-string>"www.google.com"</span>,<span class=hljs-attr>"Path"</span>:<span class=hljs-string>""</span>,<span class=hljs-attr>"RawPath"</span>:<span class=hljs-string>""</span>,<span class=hljs-attr>"ForceQuery"</span>:<span class=hljs-literal>false</span>,<span class=hljs-attr>"RawQuery"</span>:<span class=hljs-string>""</span>,<span class=hljs-attr>"Fragment"</span>:<span class=hljs-string>""</span>}}
</code></pre> <p>When service B receives the "net/url.URL" it will receive json similar to:</p> <pre class=hljs><code>{<span class=hljs-attr>"url"</span>: <span class=hljs-string>"http://www.google.com"</span>}
</code></pre> <p>In both cases the Unmarshal will fail due to the data structures not aligning correctly.</p> <p>This breaks the ability for an older service, B to talk to a new service A.</p> <h2>The Good with the Bad</h2> <p>Many developers will read this post, look at the portion of code required to achieve a common and mundane task, and write Go off as inconvenient.</p> <p>While I sympathize, and to a degree agree, I also see a valuable principal being adhered to.</p> <p>Many languages suffer from compatibility issues which not only cripple productivity but also lose real money when downtime incurs.</p> <p>Knowing the Go team is making full effort to avoid these scenarios is a good thing.</p> </article></div></div></div></div> <script>__SAPPER__={baseUrl:"",preloaded:[void 0,null,{article:{date:"2020-07-11",title:"The Good With The Bad: Go's net\u002Furl.URL and JSON",desc:"Why seemingly inconvenient approaches lead to value in the long run.",file:"go-url-encoding",html:"\u003Ch1\u003EThe Good With The Bad: Go's net\u002Furl.URL and JSON\u003C\u002Fh1\u003E\n\u003Cp\u003EA rather common task presented itself while working on \u003Ca href=\"https:\u002F\u002Fgithub.com\u002Fquay\u002Fclair\"\u003EClair\u003C\u002Fa\u003E this week.\u003C\u002Fp\u003E\n\u003Cp\u003EA URL needed to be generated in one service and communicated to another one.\nLike most would, JSON was to be used as the encoding and HTTP as the transport mechanism.\nA common task in most languages but a caveat exists in Go.\u003C\u002Fp\u003E\n\u003Cp\u003ELogically a net\u002Furl.URL would be encoded as a string and transported in JSON as such data type.\nLooking at the net\u002Furl.URL source code we see no implementations for json.Marshaler\u002Fjson.Unmarshaller nor encoding.TextMarshaller\u002Fencoding.TextUnmarshaller.\u003C\u002Fp\u003E\n\u003Cp\u003EIt becomes the programmer's responsibility to implement this behavior.\u003C\u002Fp\u003E\n\u003Ch2\u003EThe Solution\u003C\u002Fh2\u003E\n\u003Cp\u003ESeveral ways exist to solve the problem.\nThe way chosen in Clair is as follows.\u003C\u002Fp\u003E\n\u003Cpre class=\"hljs\"\u003E\u003Ccode\u003E\u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F Webhook holds the details for clients to call back the Notifier\u003C\u002Fspan\u003E\n\u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F and receive notifications.\u003C\u002Fspan\u003E\n\u003Cspan class=\"hljs-keyword\"\u003Etype\u003C\u002Fspan\u003E Webhook \u003Cspan class=\"hljs-keyword\"\u003Estruct\u003C\u002Fspan\u003E {\n\tNotificationID uuid.UUID \u003Cspan class=\"hljs-string\"\u003E`json:&quot;notification_id&quot;`\u003C\u002Fspan\u003E\n\tCallback       url.URL   \u003Cspan class=\"hljs-string\"\u003E`json:&quot;callback&quot;`\u003C\u002Fspan\u003E\n}\n\n\u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Efunc\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-params\"\u003E(wh Webhook)\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-title\"\u003EMarshalJSON\u003C\u002Fspan\u003E\u003Cspan class=\"hljs-params\"\u003E()\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-params\"\u003E([]\u003Cspan class=\"hljs-keyword\"\u003Ebyte\u003C\u002Fspan\u003E, error)\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E {\n\t\u003Cspan class=\"hljs-keyword\"\u003Evar\u003C\u002Fspan\u003E m = \u003Cspan class=\"hljs-keyword\"\u003Emap\u003C\u002Fspan\u003E[\u003Cspan class=\"hljs-keyword\"\u003Estring\u003C\u002Fspan\u003E]\u003Cspan class=\"hljs-keyword\"\u003Estring\u003C\u002Fspan\u003E{\n\t\t\u003Cspan class=\"hljs-string\"\u003E&quot;notification_id&quot;\u003C\u002Fspan\u003E: wh.NotificationID.String(),\n\t\t\u003Cspan class=\"hljs-string\"\u003E&quot;callback&quot;\u003C\u002Fspan\u003E:        wh.Callback.String(),\n\t}\n\t\u003Cspan class=\"hljs-keyword\"\u003Ereturn\u003C\u002Fspan\u003E json.Marshal(m)\n}\n\n\u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Efunc\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-params\"\u003E(wh *Webhook)\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-title\"\u003EUnmarshalJSON\u003C\u002Fspan\u003E\u003Cspan class=\"hljs-params\"\u003E(b []\u003Cspan class=\"hljs-keyword\"\u003Ebyte\u003C\u002Fspan\u003E)\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-title\"\u003Eerror\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E {\n\t\u003Cspan class=\"hljs-keyword\"\u003Evar\u003C\u002Fspan\u003E m = \u003Cspan class=\"hljs-built_in\"\u003Emake\u003C\u002Fspan\u003E(\u003Cspan class=\"hljs-keyword\"\u003Emap\u003C\u002Fspan\u003E[\u003Cspan class=\"hljs-keyword\"\u003Estring\u003C\u002Fspan\u003E]\u003Cspan class=\"hljs-keyword\"\u003Estring\u003C\u002Fspan\u003E, \u003Cspan class=\"hljs-number\"\u003E2\u003C\u002Fspan\u003E)\n\terr := json.Unmarshal(b, &amp;m)\n\t\u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E err != \u003Cspan class=\"hljs-literal\"\u003Enil\u003C\u002Fspan\u003E {\n\t\t\u003Cspan class=\"hljs-keyword\"\u003Ereturn\u003C\u002Fspan\u003E err\n\t}\n\t\u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E _, ok := m[\u003Cspan class=\"hljs-string\"\u003E&quot;notification_id&quot;\u003C\u002Fspan\u003E]; !ok {\n\t\t\u003Cspan class=\"hljs-keyword\"\u003Ereturn\u003C\u002Fspan\u003E fmt.Errorf(\u003Cspan class=\"hljs-string\"\u003E&quot;json unmarshal failed. webhook requires a \\&quot;notification_id\\&quot; field&quot;\u003C\u002Fspan\u003E)\n\t}\n\t\u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E _, ok := m[\u003Cspan class=\"hljs-string\"\u003E&quot;callback&quot;\u003C\u002Fspan\u003E]; !ok {\n\t\t\u003Cspan class=\"hljs-keyword\"\u003Ereturn\u003C\u002Fspan\u003E fmt.Errorf(\u003Cspan class=\"hljs-string\"\u003E&quot;json unmarshal failed. webhook requires a \\&quot;callback\\&quot; field&quot;\u003C\u002Fspan\u003E)\n\t}\n\n\tuid, err := uuid.Parse(m[\u003Cspan class=\"hljs-string\"\u003E&quot;notification_id&quot;\u003C\u002Fspan\u003E])\n\t\u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E err != \u003Cspan class=\"hljs-literal\"\u003Enil\u003C\u002Fspan\u003E {\n\t\t\u003Cspan class=\"hljs-keyword\"\u003Ereturn\u003C\u002Fspan\u003E fmt.Errorf(\u003Cspan class=\"hljs-string\"\u003E&quot;json unmarshal failed. malformed notification uuid: %v&quot;\u003C\u002Fspan\u003E, err)\n\t}\n\tcbURL, err := url.Parse(m[\u003Cspan class=\"hljs-string\"\u003E&quot;callback&quot;\u003C\u002Fspan\u003E])\n\t\u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E err != \u003Cspan class=\"hljs-literal\"\u003Enil\u003C\u002Fspan\u003E {\n\t\t\u003Cspan class=\"hljs-keyword\"\u003Ereturn\u003C\u002Fspan\u003E fmt.Errorf(\u003Cspan class=\"hljs-string\"\u003E&quot;json unmarshal failed. malformed callback url: %v&quot;\u003C\u002Fspan\u003E, err)\n\t}\n\n\t(*wh).NotificationID = uid\n\t(*wh).Callback = *cbURL\n\t\u003Cspan class=\"hljs-keyword\"\u003Ereturn\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-literal\"\u003Enil\u003C\u002Fspan\u003E\n}\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003EImplementing the MarshalJSON and UnmarshalJSON methods for the entire struct was feasible since it's small and maps nicely into a \u003Ccode\u003Ego map[string]string\u003C\u002Fcode\u003E data structure.\u003C\u002Fp\u003E\n\u003Cp\u003EIf the struct were larger or consisted of heterogeneous field types one may decide implementing a custom type is simpler.\u003C\u002Fp\u003E\n\u003Cp\u003EThe downside to the former approach appears in forced type conversions littering the code.\u003C\u002Fp\u003E\n\u003Ch2\u003ESo... Why\u003C\u002Fh2\u003E\n\u003Cp\u003EAn obvious question is likely rattling around your brain right now.\u003C\u002Fp\u003E\n\u003Cp\u003EWhy did the stdlib developers not implement the basic interface methods aligning with the most common use cases?\u003C\u002Fp\u003E\n\u003Cp\u003EThe source code holds a clue:\u003C\u002Fp\u003E\n\u003Cpre class=\"hljs\"\u003E\u003Ccode\u003E\u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F Marshaling interface implementations.\u003C\u002Fspan\u003E\n\u003Cspan class=\"hljs-comment\"\u003E\u002F\u002F Would like to implement MarshalText\u002FUnmarshalText but that will change the JSON representation of URLs.\u003C\u002Fspan\u003E\n\n\u003Cspan class=\"hljs-function\"\u003E\u003Cspan class=\"hljs-keyword\"\u003Efunc\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-params\"\u003E(u *URL)\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-title\"\u003EMarshalBinary\u003C\u002Fspan\u003E\u003Cspan class=\"hljs-params\"\u003E()\u003C\u002Fspan\u003E \u003Cspan class=\"hljs-params\"\u003E(text []\u003Cspan class=\"hljs-keyword\"\u003Ebyte\u003C\u002Fspan\u003E, err error)\u003C\u002Fspan\u003E\u003C\u002Fspan\u003E {\n    \u003Cspan class=\"hljs-keyword\"\u003Ereturn\u003C\u002Fspan\u003E []\u003Cspan class=\"hljs-keyword\"\u003Ebyte\u003C\u002Fspan\u003E(u.String()), \u003Cspan class=\"hljs-literal\"\u003Enil\u003C\u002Fspan\u003E\n}\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003EThe reason lies in Go's strict backwards compatibility promise.\u003C\u002Fp\u003E\n\u003Cp\u003EIn a hypothetical, lets say the appropriate marshalling methods were introduced in Go 1.14.\u003C\u002Fp\u003E\n\u003Cp\u003ETwo services exist A and B which communicate a &quot;net\u002Furl.URL&quot; structure via JSON\u002FHTTP and no custom marshalling methods were implemented like above.\u003C\u002Fp\u003E\n\u003Cp\u003EService A is rebuilt in Go 1.14.\u003C\u002Fp\u003E\n\u003Cp\u003EWhen service A receives the &quot;net\u002Furl.URL&quot; it will receive json similar to:\u003C\u002Fp\u003E\n\u003Cpre class=\"hljs\"\u003E\u003Ccode\u003E{\u003Cspan class=\"hljs-attr\"\u003E&quot;url&quot;\u003C\u002Fspan\u003E: {\u003Cspan class=\"hljs-attr\"\u003E&quot;Scheme&quot;\u003C\u002Fspan\u003E:\u003Cspan class=\"hljs-string\"\u003E&quot;http&quot;\u003C\u002Fspan\u003E,\u003Cspan class=\"hljs-attr\"\u003E&quot;Opaque&quot;\u003C\u002Fspan\u003E:\u003Cspan class=\"hljs-string\"\u003E&quot;&quot;\u003C\u002Fspan\u003E,\u003Cspan class=\"hljs-attr\"\u003E&quot;User&quot;\u003C\u002Fspan\u003E:\u003Cspan class=\"hljs-literal\"\u003Enull\u003C\u002Fspan\u003E,\u003Cspan class=\"hljs-attr\"\u003E&quot;Host&quot;\u003C\u002Fspan\u003E:\u003Cspan class=\"hljs-string\"\u003E&quot;www.google.com&quot;\u003C\u002Fspan\u003E,\u003Cspan class=\"hljs-attr\"\u003E&quot;Path&quot;\u003C\u002Fspan\u003E:\u003Cspan class=\"hljs-string\"\u003E&quot;&quot;\u003C\u002Fspan\u003E,\u003Cspan class=\"hljs-attr\"\u003E&quot;RawPath&quot;\u003C\u002Fspan\u003E:\u003Cspan class=\"hljs-string\"\u003E&quot;&quot;\u003C\u002Fspan\u003E,\u003Cspan class=\"hljs-attr\"\u003E&quot;ForceQuery&quot;\u003C\u002Fspan\u003E:\u003Cspan class=\"hljs-literal\"\u003Efalse\u003C\u002Fspan\u003E,\u003Cspan class=\"hljs-attr\"\u003E&quot;RawQuery&quot;\u003C\u002Fspan\u003E:\u003Cspan class=\"hljs-string\"\u003E&quot;&quot;\u003C\u002Fspan\u003E,\u003Cspan class=\"hljs-attr\"\u003E&quot;Fragment&quot;\u003C\u002Fspan\u003E:\u003Cspan class=\"hljs-string\"\u003E&quot;&quot;\u003C\u002Fspan\u003E}}\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003EWhen service B receives the &quot;net\u002Furl.URL&quot; it will receive json similar to:\u003C\u002Fp\u003E\n\u003Cpre class=\"hljs\"\u003E\u003Ccode\u003E{\u003Cspan class=\"hljs-attr\"\u003E&quot;url&quot;\u003C\u002Fspan\u003E: \u003Cspan class=\"hljs-string\"\u003E&quot;http:\u002F\u002Fwww.google.com&quot;\u003C\u002Fspan\u003E}\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003EIn both cases the Unmarshal will fail due to the data structures not aligning correctly.\u003C\u002Fp\u003E\n\u003Cp\u003EThis breaks the ability for an older service, B to talk to a new service A.\u003C\u002Fp\u003E\n\u003Ch2\u003EThe Good with the Bad\u003C\u002Fh2\u003E\n\u003Cp\u003EMany developers will read this post, look at the portion of code required to achieve a common and mundane task, and write Go off as inconvenient.\u003C\u002Fp\u003E\n\u003Cp\u003EWhile I sympathize, and to a degree agree, I also see a valuable principal being adhered to.\u003C\u002Fp\u003E\n\u003Cp\u003EMany languages suffer from compatibility issues which not only cripple productivity but also lose real money when downtime incurs.\u003C\u002Fp\u003E\n\u003Cp\u003EKnowing the Go team is making full effort to avoid these scenarios is a good thing.\u003C\u002Fp\u003E\n"}}]};if('serviceWorker' in navigator)navigator.serviceWorker.register('/service-worker.js');</script><script src=/client/21d5f7fc0374dd879b15/main.js></script> 