{"date":"2020-9-22","title":"The Absolute Minimum Every Software Developer Must Know About Cryptography","desc":"What every developer should know about crytography to make their lifes easier.","file":"absolute-minimum-cryptography","html":"<h1>The Absolute Minimum Every Software Engineer Must Know About Cryptographic Authentication and Encryption</h1>\n<h1>Introduction</h1>\n<p>It's common to hear engineers muttering &quot;cryptography is scary&quot; or &quot;oh no its a cert problem.&quot;</p>\n<p>The topic is a dense one full of maths, mailing lists, and vulnerabilities which quite literally shock the world.\nIt's understandable how a lot of engineers put learning about the topics to another day.</p>\n<p>In my career I have been asked to build two different certificate signing backends for IoT purposes.\nThese tasks provided the opportunity to work with authentication, encryption, and cryptography at a lower level then typical.</p>\n<p>This post will outline the bare minimum engineers should understand before working with authentication and encryption systems.</p>\n<h2>Part 1: Conceptual Overview</h2>\n<p>This section will provide a gentle introduction to authentication and encryption.\nThese topics are to be read as a conceptual overview and not as literal implementation details.</p>\n<h3>Authentication and Encryption</h3>\n<p>Cryptography can lend itself to many utilities but as software developers our usage centers around authentication and encryption.</p>\n<p>Authentication is the act of identification.\nCryptography can guarantee authentication and thus provide trust that the subject you are communicating with is indeed who they say they are.\nAuthentication is implemented by cryptographic signing.</p>\n<p>Encryption is the act of concealing communications from unintended audiences.\nWhen a communication is encrypted it is guaranteed to be viewable only by the intended party.</p>\n<p>Authentication and encryption are used together to device a notion of trust in our applications and on the internet.</p>\n<h3>Cryptographic Signing</h3>\n<p>Cryptographically signing a message proves authentication in a single direction. It works like so:</p>\n<ul>\n<li>Sender: constructs a message to be sent.</li>\n<li>Sender: constructs a key to sign the message with.</li>\n<li>Sender: uses a signing algorithm to sign the bits of the message with the constructed keys.</li>\n<li>Sender: sends message along with signature to client.</li>\n<li>Receiver: receives the message and signature.</li>\n<li>Receiver: retrieves the sender's key.</li>\n<li>Receiver: uses the sender's key to sign the received message.</li>\n<li>Receiver: compares the sender's signature with the one computed by the receiver itself.</li>\n</ul>\n<p>If the receiver sees both signatures as equal and knows it can trust the key used to create the signature, the receiver can trust the message is from the sender.</p>\n<p>The various ways to securely transfer the sender's key to the receiver will be covered a bit later in the post.</p>\n<p>Typical signing algorithms are:</p>\n<ul>\n<li>HS256 - HMAC with SHA256</li>\n<li>RSA256 - RSA Signature with SHA256</li>\n</ul>\n<h3>Cryptographic Encryption</h3>\n<p>While similar in procedure, cryptographic encryption serves a separate purpose. It works like so:</p>\n<ul>\n<li>Sender: constructs a key</li>\n<li>Sender: construct a message to send</li>\n<li>Sender: run the message bits and the key through an encryption algorithm, producing unintelligible ciphertext.</li>\n<li>Sender: sends cipher text message to receiver.</li>\n<li>Receiver: receives the message</li>\n<li>Receiver: retrieves the sender's key</li>\n<li>Receiver: runs the message's ciphertext and the retrieved key through the same encryption algorithm, producing an intelligible message.</li>\n</ul>\n<p>In the above scenario the key is being utilized on every message to encrypt the message and conceal its contents.</p>\n<p>Typical encryption algorithms are:</p>\n<ul>\n<li>DES &amp; 3DES</li>\n<li>RSA</li>\n<li>Blowfish</li>\n<li>AES</li>\n</ul>\n<h2>Part 2: Applied Technologies</h2>\n<p>Several widely used technologies apply signing and encryption in practice. We will cover the following:</p>\n<ul>\n<li>Private Key Infrastructure And x509 Certificates</li>\n<li>TLS (SSL)</li>\n<li>JSON Web Tokens / JSON Web Signatures</li>\n</ul>\n<h3>Private Key Infrastructure And x509 Certificates</h3>\n<p>Private key infrastructure, or PKI for short, is a grouping of technologies, protocols, and policies.\nThis grouping can be used in tandem to ensure both authentication and encryption and securely transfer keys between parties.</p>\n<p>PKI is based on a private/public key model.\nIn this model a private key is used for signing or encryption while the public key is used for verification or decryption.</p>\n<p>*aside: Often the terms &quot;asymmetric&quot; and &quot;symmetric&quot; encryption come up. When the same key is used to encrypt and decrypt a message, this is known as &quot;symmetric&quot; encryption. When a key is used to encrypt a message as a different key is used to decrypt the message, this is known as &quot;asymmetric&quot; encryption. Public/Private key encryption is considered &quot;asymmetric&quot;.</p>\n<p>The private key is kept secret and used to sign data while the public key can verify what the private key signs.\nThe public key can never be used to derive the private key and this is mathematically proven.</p>\n<p><em>aside: PKI infrastructure will typically use RSA public and private keys. We dig into this more later in the post.</em></p>\n<p>In our examples above the sender would sign a message with its private key, make its public key available to the receiver, and the receiver would verify the message utilizing the sender's public key.</p>\n<p>PKI is called an 'infrastructure' because it provides a trust policy in addition to authentication and encryption.</p>\n<p>In PKI the trust policy takes the form of a tree.\nAt the root of the tree is the &quot;root CA&quot;, where CA is short for certificate authority.\nThe root can create one or more &quot;intermediate CA(s)&quot; by creating and signing their certificate with its own private key, providing authenticity that the intermediate CA was created by the root.\nThis creates a chain of trust as I can confirm an intermediate is signed by its root by obtaining the root's public key and verifying the certificate's signature.</p>\n<p>The intermediate CA is then kept online while the root CA is kept offline.\nThis is for security purposes, if the intermediate CA private keys are compromised they can be revoked and the collateral damage can be managed.\nIf the root CA's key is compromised all certificates created by any CA in the tree must be revoked.</p>\n<p>A diagram can help provide a visual aide.</p>\n<p><img src=\"./pki_hierarchy_diagram.png\" alt=\"pki hierarchy diagram\"></p>\n<p>Each node in the chain has both a private key and a certificate.</p>\n<p>PKI utilizes a standardized certificate model specified in <a href=\"https://tools.ietf.org/html/rfc2459\">rfc-2459</a>.</p>\n<p>A certificate is an envelope containing metadata and the public key of the owner. It may be used as follows:</p>\n<ul>\n<li>Sender: Signs a message with it's private key.</li>\n<li>Sender: Sends message to receiver.</li>\n<li>Receiver: Receives message.</li>\n<li>Receiver: Obtains the sender's certificate.</li>\n<li>Receiver: Verifies the certificate's authenticity by following the certificate trust chain.</li>\n<li>Receiver: Extracts public key from certificate and verifies message.</li>\n</ul>\n<p>Note that it is not enough to simply extract the public key and verify the message.\nThe receiver must verify the encountered certificate was indeed signed by the issuer's private key.\nThis is typically performed by the receiver having a local copy of popular root and intermediate certificates, extracting the public key from the one matching the issuer of the encountered certificate, and verifying the signature.</p>\n<p>It is worthwhile to take a pragmatic look at setting up a root CA, intermediate, and signing client certificates.\nA wonderful tutorial can be found <a href=\"https://jamielinux.com/docs/openssl-certificate-authority/\">here</a></p>\n<h3>TLS</h3>\n<p>TLS utilizes PKI to implement encryption over HTTP also known as &quot;HTTPS&quot;.\nTLS guarantees that every bit of data between two HTTP clients is encrypted and unintelligible to any other parties which may route the traffic.</p>\n<p>TLS is a protocol which exchanges asymmetric keys, generates symmetric keys, and uses the symmetric keys to encrypt data between parties.</p>\n<p>When a browser connects to an HTTPS website a handshake occurs.\nWithin this handshake the server's certificate is verified and a set of symmetric keys are crafted.\nAll communication on this secure channel is now encrypted and decrypted with the symmetric keys.</p>\n<p>The reason symmetric keys are used is for performance.\nEncrypting and decrypting with a private/public key can be expensive due to key size.\nEncryption and decryption can occur quicker with smaller symmetric keys.</p>\n<p>TLS also provides authentication.</p>\n<p>Each https server is assigned a client certificate.\nFrom our PKI diagram, client certificates are the leafs.\nWhen a user requests information from a server, the user's browser will check the server's certificate.\nIf the browser cannot prove the certificate was created by a trusted root or intermediate CA the connection will fail.</p>\n<p><em>aside: if you ever had to install a certificate bundle to a server because ssl was failing you are installing a well known set of trusted root and intermediate certificates. This is used in the above verification process.</em></p>\n<p>With TLS comes maintenance.\nTLS certificates expire over time and must be kept up to date.\nTraditionally a server TLS certificate would be purchased from a well known root CA such as DigiTrust.\nToday, &quot;let's encrypt&quot; has paved the way for free certificates, albeit these certs expire much sooner then ones you can purchase from a trusted root ca.</p>\n<h3>JSON Web Tokens and JSON Web Encryption</h3>\n<p>JSON Web Tokens or JWT for short has become a popular form of authentication in modern web applications.\nWhen coupled with JSON Web Encryption both authentication and encryption can be utilized.</p>\n<p>The ubiquity of JWT and JSE is due to it's simplicity and ease of use.\nBoth specifications use JSON to transfer a signed and optionally encrypted token between parties.</p>\n<p>This token can optionally contain claims, key/value information potentially useful for the receiving party along with several other &quot;sections&quot; which are base64 encoded and signed.\nThe full details of generating a token can be viewed <a href=\"https://jwt.io/introduction/\">here</a>.</p>\n<p>The flow of jwt interaction follows:</p>\n<ul>\n<li>Sender: generates the header and the payload for the JWT.</li>\n<li>Sender: generate the signature for the JWT utilizing a key.</li>\n<li>Sender: places the token in an &quot;authorization&quot; http header.</li>\n<li>Receiver: parses the &quot;authorization&quot; header and retrieves the token.</li>\n<li>Receiver: retrieves the sender's key.</li>\n<li>Receiver: verifies the signature portion with the sender's key.</li>\n</ul>\n<p>JWT alone provides no key transfer facilities and the token's data is in plain text.\nHowever, with JSON Web Encryption (JWE) it becomes possible to piggyback off PKI and retrieve public keys via the public key infrastructure.</p>\n<p>More than a high level overview is further then this post would like to go.\nIf you are interested in further details on JWT and JWE I suggest checking out the <a href=\"https://tools.ietf.org/html/rfc7519\">JWT RFC</a> and <a href=\"https://tools.ietf.org/html/rfc7516\">JWE RFC</a> directly.</p>\n<p>Understanding this post will lend itself to utilizing JWT and JWE without much difficulty, as their components build on the fundamentals.</p>\n<h2>Part 2: Encodings</h2>\n<p>The following topics will describe the ubiquitous encoding formats encountered in modern authentication and encryption applications.</p>\n<h3>It All Starts With ASN.1</h3>\n<p>ASN.1 is a language for <strong>describing</strong> encodings.</p>\n<p>A user of ASN.1 can write out ASN.1 data types.</p>\n<p>A consumer of ASN.1 definitions program how these objects will serialize to disk or a network wire.\nThis is referred to as an &quot;encoding&quot; of ASN.1 types.</p>\n<p>For example an ASN.1 definition may describe a data structure comprised of two integer fields, an array of integers field, and a string field in a similar fashion as a structure in Go.</p>\n<pre class=\"hljs\"><code><span class=\"hljs-keyword\">type</span> Obj <span class=\"hljs-keyword\">struct</span> {\n  X <span class=\"hljs-keyword\">int</span>\n  Y <span class=\"hljs-keyword\">int</span>\n  Values []<span class=\"hljs-keyword\">int</span>\n  Name <span class=\"hljs-keyword\">string</span>\n}\n</code></pre>\n<p>Just as we can take any Go struct with public members and encode it into JSON, ASN.1 provides a common language to define structures and encode it into several forms.</p>\n<p>ASN.1 is heavily used in the telecommunication industry and remains popular due to its extensibility.</p>\n<h4>DER</h4>\n<p>DER specifies a set of rules for encoding ASN.1 objects into binary.</p>\n<p>Any objects described in ASN.1 can be encoded into DER and serialized as binary.</p>\n<p>Libraries will often return DER encoded keys and certificates when crafting cryptographic primitives.\nIt can be convenient for applications to work with DER as any penalty for marshalling/unmarshalling the binary to ASCII is not present.</p>\n<h4>PEM</h4>\n<p>PEM is simply the base64 encoded DER data surrounded by a block of ASCII text.\nSince DER can encode several ASN.1 formats and PEM simply holds a base64 representation of this data, PEM can hold multiple ASN.1 described formats transitively.</p>\n<p>PEM is the encoding public keys, private keys, and certificates are typically transported in, as they are human readable and can be instantly recognized.</p>\n<p>A PEM private key follows:</p>\n<pre class=\"hljs\"><code>-----BEGIN RSA PRIVATE KEY-----\nMIIEpQIBAAKCAQEA3Tz2mr7SZiAMfQyuvBjM9Oi..Z1BjP5CE/Wm/Rr500P\nRK+Lh9x5eJPo5CAZ3/ANBE0sTK0ZsDGMak2m1g7..3VHqIxFTz0Ta1d+NAj\nwnLe4nOb7/eEJbDPkk05ShhBrJGBKKxb8n104o/..PdzbFMIyNjJzBM2o5y\n5A13wiLitEO7nco2WfyYkQzaxCw0AwzlkVHiIyC..71pSzkv6sv+4IDMbT/\nXpCo8L6wTarzrywnQsh+etLD6FtTjYbbrvZ8RQM..Hg2qxraAV++HNBYmNW\ns0duEdjUbJK+ZarypXI9TtnS4o1Ckj7POfljiQI..IBAFyidxtqRQyv5KrD\nkbJ+q+rsJxQlaipn2M4lGuQJEfIxELFDyd3XpxP..Un/82NZNXlPmRIopXs\n2T91jiLZEUKQw+n73j26adTbteuEaPGSrTZxBLR..yssO0wWomUyILqVeti\n6AkL0NJAuKcucHGqWVgUIa4g1haE0ilcm6dWUDo..fd+PpzdCJf1s4NdUWK\nYV2GJcutGQb+jqT5DTUqAgST7N8M28rwjK6nVMI..BUpP0xpPnuYDyPOw6x\n4hBt8DZQYyduzIXBXRBKNiNdv8fum68/5klHxp6..4HRkMUL958UVeljUsT\nBFQlO9UCgYEA/VqzXVzlz8K36VSTMPEhB5zBATV..PRiXtYK1YpYV4/jSUj\nvvT4hP8uoYNC+BlEMi98LtnxZIh0V4rqHDsScAq..VyeSLH0loKMZgpwFEm\nbEIDnEOD0nKrfT/9K9sPYgvB43wsLEtUujaYw3W..Liy0WKmB8CgYEA34xn\n1QlOOhHBn9Z8qYjoDYhvcj+a89tD9eMPhesfQFw..rsfGcXIonFmWdVygbe\n6Doihc+GIYIq/QP4jgMksE1ADvczJSke92ZfE2i..fitBpQERNJO0BlabfP\nALs5NssKNmLkWS2U2BHCbv4DzDXwiQB37KPOL1c..kBHfF2/htIs20d1UVL\n+PK+aXKwguI6bxLGZ3of0UH+mGsSl0mkp7kYZCm..OTQtfeRqP8rDSC7DgA\nkHc5ajYqh04AzNFaxjRo+M3IGICUaOdKnXd0Fda..QwfoaX4QlRTgLqb7AN\nZTzM9WbmnYoXrx17kZlT3lsCgYEAm757XI3WJVj..WoLj1+v48WyoxZpcai\nuv9bT4Cj+lXRS+gdKHK+SH7J3x2CRHVS+WH/SVC..DxuybvebDoT0TkKiCj\nBWQaGzCaJqZa+POHK0klvS+9ln0/6k539p95tfX..X4TCzbVG6+gJiX0ysz\nYfehn5MCgYEAkMiKuWHCsVyCab3RUf6XA9gd3qY..fCTIGtS1tR5PgFIV+G\nengiVoWc/hkj8SBHZz1n1xLN7KDf8ySU06MDggB..hJ+gXJKy+gf3mF5Kmj\nDtkpjGHQzPF6vOe907y5NQLvVFGXUq/FIJZxB8k..fJdHEm2M4=\n-----END RSA PRIVATE KEY-----\n</code></pre>\n<p>Because the base64 value can be several ASN.1 descriptions the PEM encoding wraps the base64 data with some header information.\nThis is helpful for libraries which parse and decode these files.</p>\n<h4>PKCS8 and PKIX</h4>\n<p>PKCS8 and PKIX are formats specifically utilized for encoding a private key and a public key respectively.\nThe former is part of a larger set of <a href=\"https://en.wikipedia.org/wiki/PKCS\">PKCS protocols</a> defined by the RSA organization.\nThe latter is defined by the Public Key Infrastructure working in <a href=\"https://tools.ietf.org/html/rfc5280#section-4.1\">rfc-5280 section4.1</a>:</p>\n<pre class=\"hljs\"><code>SubjectPublicKeyInfo  ::=  SEQUENCE  {\n     algorithm            AlgorithmIdentifier,\n     subjectPublicKey     BIT STRING  }\n</code></pre>\n<p>Both these formats are expressed in ASN.1 notation, therefore they can be DER encoded and subsequently PEM encoded.</p>\n<p>These formats support password protection utilizing symmetric keys where both DER and PEM do not.</p>\n<h3>RSA Keys And Certificates</h3>\n<p>RSA keys are often used with x.509 certificates. As a reminder certificates are used to prove authenticity.</p>\n<p>The certificate has a public key and enough information to prove this key is from who the receiver thinks it is.</p>\n<p>A certificate is yet another ASN.1 described object defined in the <a href=\"https://tools.ietf.org/html/rfc5280\">rfc-5280</a> and can be marshalled to DER and PEM just like the others.</p>\n<h2>Part 3: An example</h2>\n<p>Generate a RSA Key Pair.</p>\n<pre class=\"hljs\"><code>f, err := os.Open(<span class=\"hljs-string\">&quot;/dev/random&quot;</span>)\n<span class=\"hljs-keyword\">if</span> err != <span class=\"hljs-literal\">nil</span> {\n    log.Fatal(err)\n}\nprivate, err := rsa.GenerateKey(f, <span class=\"hljs-number\">4096</span>)\n</code></pre>\n<p>The above uses &quot;/dev/random&quot; as a random seed source and creates a 4096 bit key pair.</p>\n<p>The public key can be extracted from the private.</p>\n<pre class=\"hljs\"><code>public := private.Public()\n</code></pre>\n<p>Both <code>private</code> and <code>public</code> variables hold a language specific key object with fields specific to the RSA algorithm.</p>\n<p>We want to transport the public key, both PKCS1 and PKIX are formats that can accomplish this. Since we covered PKIX in this post lets use that format.</p>\n<pre class=\"hljs\"><code>der, err := x509.MarshalPKIXPublicKey(public)\n</code></pre>\n<p>This marshal function will take the language specific public key object, marshall it into the ASN.1 PKIX description, and then encode this ASN.1 description into binary.\nThe <code>der</code> variable holds a byte slice containing the DER encoding of the private key.</p>\n<p>If the goal is to simply store a public key in a database the binary DER encoding fulfills this use case.\nHowever, if the key must transit a transport that is not byte safe such as a network or email system we must PEM encoded the byte slice.</p>\n<p>In order to PEM encode our DER encoded PKIX public key we need to create a PEM block.</p>\n<pre class=\"hljs\"><code>type Block struct {\n    Type    string            // The type, taken from the preamble (i.e. &quot;RSA PRIVATE KEY&quot;).\n    Headers map[string]string // Optional headers.\n    Bytes   []byte            // The decoded bytes of the contents. Typically a DER encoded ASN.1 structure.\n}\n</code></pre>\n<p>The structure defines a few fields.</p>\n<p><code>Type</code> is ASCII text which defines the binary data being encoded.\nFor a PKIX public key this should be &quot;PUBLIC KEY&quot;.</p>\n<p>Headers allow for further details about the binary we are encoding, we will not use this.</p>\n<p>Finally the <code>Bytes</code> field contains the binary data we are going to base64 encode into ASCII.\nRemember a PEM is simply the base64 encoded binary data with some ASCII type and header information heading and footing the results.</p>\n<pre class=\"hljs\"><code>block := pem.Block{\n    Type:  <span class=\"hljs-string\">&quot;PUBLIC KEY&quot;</span>,\n    Bytes: der,\n}\npem := pem.EncodeToMemory(block)\n</code></pre>\n<p>The above defines the block and encodes our binary PKIX key into an ASCII PEM format.</p>\n<p>At this point we can print the pem encoded key and see a familiar sight.</p>\n<pre class=\"hljs\"><code>fmt.Print(<span class=\"hljs-keyword\">string</span>(pem))\n</code></pre>\n<pre class=\"hljs\"><code>-----BEGIN PUBLIC KEY-----\nMIICCgKCAgEAsWQmmNw+gBRR2vq59w2LyUtJ/E3kKiatjGYmpTuSlrzbIiXNL3qz\nxWGUhgux6UYJlEReT6eCwIfVJvVGJVRl/cL5ji3FCg+PAUqkn9BIFODx1MHWyWDe\n4/nQpfNpW7NjPW90M2yYR3YVKscyupidpJS3o99Iay3KmYn1xJ6HBaFTx3WXo9xG\nvqDY8uVGzcawUiTe3S2FUaKwi5SWU2bb98gzrQ1vTLej01Wh8mH6w+rrnZy5l+nz\ngrRqVbVwP7Q2LbcrbJGj8P3RT+3RafuP4S0Xf9X6IbNsAFYLFDarMwlB9cnVda3v\nCgHuGPqwBWU9KaXT1XRhdnvqX7dBi48GFOKyiD0jULY50sxLbGHCoWno0OUHFuZ4\n36kRAtTJOVTMt0yuUT9rfIfthdo8sCcQxamTmE3AFZs1/aKu8/wKJn6XfXSQjBPD\nhHXi1k9v1pMIjqUPWIo6JVtuuctX6ypTq3Q8PbJ4XCybIDemA7juKG3idyruUXS+\n09cCQkQ6sylVDHwmaskowcC5H5G87xdrXl8NyAkh+oq3hVBSG0lCQeDWVvsua8L5\ngxHQwz9xDtXKDXkZk7ovyVGISAKBpW7o4VBnE3zkpOQGluH/QfUWjX/fiD6cazz6\nmsBtiBSSjM6yL+CosTSarhgd1qB0y3/ZgwDTRL+Ax2vvmiz06mfSjsUCAwEAAQ==\n-----END PUBLIC KEY-----\n</code></pre>\n<h2>Conclusion</h2>\n<p>A novice's view of cryptography is clouded by unfamiliar terminology and acronyms.\nThis often leads to engineers avoiding the subject all together.</p>\n<p>This post makes it apparent that working with cryptography in a pragmatic sense has parallels with json or protobuf.\nAt the end of the day, we describe a machine agnostic definition of an object (ASN.1), specify a way to encode this description (DER), and optionally modify the binary encoding to be network and email friendly (PEM).</p>\n<p>With this new perspective tasks dealing with certificates, ssl, authentication, and encryption should be demystified enough to tackle.</p>\n"}