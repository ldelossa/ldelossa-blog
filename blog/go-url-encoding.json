{"date":"2020-07-11","title":"The Good With The Bad: Go's net/url.URL and JSON","desc":"Why seemingly inconvenient approaches lead to value in the long run.","file":"go-url-encoding","html":"<h1>The Good With The Bad: Go's net/url.URL and JSON</h1>\n<p>A rather common task presented itself while working on <a href=\"https://github.com/quay/clair\">Clair</a> this week.</p>\n<p>A URL needed to be generated in one service and communicated to another one.\nLike most would, JSON was to be used as the encoding and HTTP as the transport mechanism.\nA common task in most languages but a caveat exists in Go.</p>\n<p>Logically a net/url.URL would be encoded as a string and transported in JSON as such data type.\nLooking at the net/url.URL source code we see no implementations for json.Marshaler/json.Unmarshaller nor encoding.TextMarshaller/encoding.TextUnmarshaller.</p>\n<p>It becomes the programmer's responsibility to implement this behavior.</p>\n<h2>The Solution</h2>\n<p>Several ways exist to solve the problem.\nThe way chosen in Clair is as follows.</p>\n<pre class=\"hljs\"><code><span class=\"hljs-comment\">// Webhook holds the details for clients to call back the Notifier</span>\n<span class=\"hljs-comment\">// and receive notifications.</span>\n<span class=\"hljs-keyword\">type</span> Webhook <span class=\"hljs-keyword\">struct</span> {\n\tNotificationID uuid.UUID <span class=\"hljs-string\">`json:&quot;notification_id&quot;`</span>\n\tCallback       url.URL   <span class=\"hljs-string\">`json:&quot;callback&quot;`</span>\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(wh Webhook)</span> <span class=\"hljs-title\">MarshalJSON</span><span class=\"hljs-params\">()</span> <span class=\"hljs-params\">([]<span class=\"hljs-keyword\">byte</span>, error)</span></span> {\n\t<span class=\"hljs-keyword\">var</span> m = <span class=\"hljs-keyword\">map</span>[<span class=\"hljs-keyword\">string</span>]<span class=\"hljs-keyword\">string</span>{\n\t\t<span class=\"hljs-string\">&quot;notification_id&quot;</span>: wh.NotificationID.String(),\n\t\t<span class=\"hljs-string\">&quot;callback&quot;</span>:        wh.Callback.String(),\n\t}\n\t<span class=\"hljs-keyword\">return</span> json.Marshal(m)\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(wh *Webhook)</span> <span class=\"hljs-title\">UnmarshalJSON</span><span class=\"hljs-params\">(b []<span class=\"hljs-keyword\">byte</span>)</span> <span class=\"hljs-title\">error</span></span> {\n\t<span class=\"hljs-keyword\">var</span> m = <span class=\"hljs-built_in\">make</span>(<span class=\"hljs-keyword\">map</span>[<span class=\"hljs-keyword\">string</span>]<span class=\"hljs-keyword\">string</span>, <span class=\"hljs-number\">2</span>)\n\terr := json.Unmarshal(b, &amp;m)\n\t<span class=\"hljs-keyword\">if</span> err != <span class=\"hljs-literal\">nil</span> {\n\t\t<span class=\"hljs-keyword\">return</span> err\n\t}\n\t<span class=\"hljs-keyword\">if</span> _, ok := m[<span class=\"hljs-string\">&quot;notification_id&quot;</span>]; !ok {\n\t\t<span class=\"hljs-keyword\">return</span> fmt.Errorf(<span class=\"hljs-string\">&quot;json unmarshal failed. webhook requires a \\&quot;notification_id\\&quot; field&quot;</span>)\n\t}\n\t<span class=\"hljs-keyword\">if</span> _, ok := m[<span class=\"hljs-string\">&quot;callback&quot;</span>]; !ok {\n\t\t<span class=\"hljs-keyword\">return</span> fmt.Errorf(<span class=\"hljs-string\">&quot;json unmarshal failed. webhook requires a \\&quot;callback\\&quot; field&quot;</span>)\n\t}\n\n\tuid, err := uuid.Parse(m[<span class=\"hljs-string\">&quot;notification_id&quot;</span>])\n\t<span class=\"hljs-keyword\">if</span> err != <span class=\"hljs-literal\">nil</span> {\n\t\t<span class=\"hljs-keyword\">return</span> fmt.Errorf(<span class=\"hljs-string\">&quot;json unmarshal failed. malformed notification uuid: %v&quot;</span>, err)\n\t}\n\tcbURL, err := url.Parse(m[<span class=\"hljs-string\">&quot;callback&quot;</span>])\n\t<span class=\"hljs-keyword\">if</span> err != <span class=\"hljs-literal\">nil</span> {\n\t\t<span class=\"hljs-keyword\">return</span> fmt.Errorf(<span class=\"hljs-string\">&quot;json unmarshal failed. malformed callback url: %v&quot;</span>, err)\n\t}\n\n\t(*wh).NotificationID = uid\n\t(*wh).Callback = *cbURL\n\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">nil</span>\n}\n</code></pre>\n<p>Implementing the MarshalJSON and UnmarshalJSON methods for the entire struct was feasible since it's small and maps nicely into a <code>go map[string]string</code> data structure.</p>\n<p>If the struct were larger or consisted of heterogeneous field types one may decide implementing a custom type is simpler.</p>\n<p>The downside to the former approach appears in forced type conversions littering the code.</p>\n<h2>So... Why</h2>\n<p>An obvious question is likely rattling around your brain right now.</p>\n<p>Why did the stdlib developers not implement the basic interface methods aligning with the most common use cases?</p>\n<p>The source code holds a clue:</p>\n<pre class=\"hljs\"><code><span class=\"hljs-comment\">// Marshaling interface implementations.</span>\n<span class=\"hljs-comment\">// Would like to implement MarshalText/UnmarshalText but that will change the JSON representation of URLs.</span>\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(u *URL)</span> <span class=\"hljs-title\">MarshalBinary</span><span class=\"hljs-params\">()</span> <span class=\"hljs-params\">(text []<span class=\"hljs-keyword\">byte</span>, err error)</span></span> {\n    <span class=\"hljs-keyword\">return</span> []<span class=\"hljs-keyword\">byte</span>(u.String()), <span class=\"hljs-literal\">nil</span>\n}\n</code></pre>\n<p>The reason lies in Go's strict backwards compatibility promise.</p>\n<p>In a hypothetical, lets say the appropriate marshalling methods were introduced in Go 1.14.</p>\n<p>Two services exist A and B which communicate a &quot;net/url.URL&quot; structure via JSON/HTTP and no custom marshalling methods were implemented like above.</p>\n<p>Service A is rebuilt in Go 1.14.</p>\n<p>When service A receives the &quot;net/url.URL&quot; it will receive json similar to:</p>\n<pre class=\"hljs\"><code>{<span class=\"hljs-attr\">&quot;url&quot;</span>: {<span class=\"hljs-attr\">&quot;Scheme&quot;</span>:<span class=\"hljs-string\">&quot;http&quot;</span>,<span class=\"hljs-attr\">&quot;Opaque&quot;</span>:<span class=\"hljs-string\">&quot;&quot;</span>,<span class=\"hljs-attr\">&quot;User&quot;</span>:<span class=\"hljs-literal\">null</span>,<span class=\"hljs-attr\">&quot;Host&quot;</span>:<span class=\"hljs-string\">&quot;www.google.com&quot;</span>,<span class=\"hljs-attr\">&quot;Path&quot;</span>:<span class=\"hljs-string\">&quot;&quot;</span>,<span class=\"hljs-attr\">&quot;RawPath&quot;</span>:<span class=\"hljs-string\">&quot;&quot;</span>,<span class=\"hljs-attr\">&quot;ForceQuery&quot;</span>:<span class=\"hljs-literal\">false</span>,<span class=\"hljs-attr\">&quot;RawQuery&quot;</span>:<span class=\"hljs-string\">&quot;&quot;</span>,<span class=\"hljs-attr\">&quot;Fragment&quot;</span>:<span class=\"hljs-string\">&quot;&quot;</span>}}\n</code></pre>\n<p>When service B receives the &quot;net/url.URL&quot; it will receive json similar to:</p>\n<pre class=\"hljs\"><code>{<span class=\"hljs-attr\">&quot;url&quot;</span>: <span class=\"hljs-string\">&quot;http://www.google.com&quot;</span>}\n</code></pre>\n<p>In both cases the Unmarshal will fail due to the data structures not aligning correctly.</p>\n<p>This breaks the ability for an older service, B to talk to a new service A.</p>\n<h2>The Good with the Bad</h2>\n<p>Many developers will read this post, look at the portion of code required to achieve a common and mundane task, and write Go off as inconvenient.</p>\n<p>While I sympathize, and to a degree agree, I also see a valuable principal being adhered to.</p>\n<p>Many languages suffer from compatibility issues which not only cripple productivity but also lose real money when downtime incurs.</p>\n<p>Knowing the Go team is making full effort to avoid these scenarios is a good thing.</p>\n"}