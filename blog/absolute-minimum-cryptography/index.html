<!doctype html> <html lang=en> <head> <meta charset=utf-8> <meta content="width=device-width,initial-scale=1" name=viewport> <meta content=#333333 name=theme-color> <base href=/ > <link href=global.css rel=stylesheet> <link href=manifest.json rel=manifest crossorigin=use-credentials> <link href=favicon.png rel=icon type=image/png> <link href=https://meyerweb.com/eric/tools/css/reset/reset.css rel=stylesheet> <link href="https://fonts.googleapis.com/css2?family=Baloo+Paaji+2:wght@500&display=swap" rel=stylesheet> <link href="https://fonts.googleapis.com/css2?family=Source+Code+Pro&display=swap" rel=stylesheet> <link href="https://fonts.googleapis.com/css2?family=Muli&display=swap" rel=stylesheet> <link href=github-markdown.css rel=stylesheet> <link href=//cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/zenburn.min.css rel=stylesheet> <script src=//cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js></script> <script src=//gc.zgo.at/count.js async data-goatcounter=https://ldelossa.goatcounter.com/count></script> <style>.layout.svelte-lybuj1{display:grid;height:100vh;width:100vw;grid-template-columns:1.5fr 6fr}.content-wrapper.svelte-lybuj1{grid-area:1/2/2/3;overflow-y:auto}.content-wrapper-full.svelte-lybuj1{grid-area:1/1/2/3}@media screen and (max-width:600px){.layout.svelte-lybuj1{display:grid;grid-template-columns:1fr}.content-wrapper.svelte-lybuj1{z-index:1}.content-wrapper-full.svelte-lybuj1{z-index:1}}.sidebar-open.svelte-posnvr{display:flex;justify-content:space-between;flex-direction:column;height:100vh;max-width:300px;min-width:275px;margin-right:1vmin;background:#4b6777;overflow-y:hidden}.sidebar-closed.svelte-posnvr{display:none}.sb-toggle-button-open.svelte-posnvr{z-index:100;outline:0;background-color:Transparent;border:none;padding:10px 12px;font-size:30px;cursor:pointer;color:#f3f8f2;font-family:Muli,cursive;position:fixed;left:0}.sb-toggle-button-open.svelte-posnvr:hover{color:#f2511b}.sb-toggle-button-closed.svelte-posnvr{z-index:100;outline:0;background-color:Transparent;border:none;padding:10px 12px;font-size:30px;cursor:pointer;color:#4b6777;font-family:Muli,cursive;position:fixed;left:0}.sb-toggle-button-closed.svelte-posnvr:hover{color:#f2511b}.author-wrapper.svelte-posnvr{display:flex;flex-direction:column;justify-content:center;margin:40px}.author.svelte-posnvr{text-align:center;font-size:2rem;color:#f3f8f2;font-family:Muli,sans-serif;letter-spacing:1px;text-shadow:2px 2px 0 rgba(0,0,0,.35),2px 2px 5px rgba(0,0,0,.5)}.console-wrapper.svelte-posnvr{display:flex;margin:20px;justify-content:center}nav.svelte-posnvr{display:flex;flex-direction:column;justify-content:space-around;flex-wrap:wrap}.icons-wrapper.svelte-posnvr{display:flex;flex-direction:column;justify-content:flex-end;padding:20px}@media screen and (max-width:600px){.sidebar-open.svelte-posnvr{-moz-box-shadow:initial;-webkit-box-shadow:initial;box-shadow:initial;max-width:initial;min-width:initial;margin-right:initial;border-right:initial;height:100vh;width:100vw}.icons-wrapper.svelte-posnvr{display:flex;grid-area:icons;flex-direction:column;justify-content:space-between}}pre.svelte-wc9ma6 code.svelte-wc9ma6{border-radius:3%;padding:8px;display:block;min-width:230px;max-width:275px;background:#333;color:#737373}.button-wrapper.svelte-n868dk{text-align:center;margin:1rem 0 1rem 0;padding:1rem 1rem 1rem 1rem}.button-ref.svelte-n868dk{text-decoration:underline;font-size:30px;color:#e9f1f7;font-family:Muli,sans-serif;letter-spacing:1px;text-shadow:2px 2px 0 rgba(0,0,0,.35),2px 2px 5px rgba(0,0,0,.5)}.button-ref.svelte-n868dk:hover{color:#f2511b;text-shadow:-1px -1px 0 rgba(242,81,27,.5),-1px -1px -5px rgba(242,81,27,.5)}.icons.svelte-13lfieo{display:flex;flex-direction:row;justify-content:space-around;flex-wrap:wrap}img.svelte-13lfieo{width:30px;height:30px}img.svelte-13lfieo:hover{-webkit-filter:drop-shadow(2px 2px 2px #222);filter:drop-shadow(2px 2px 2px #222)}.blog-wrapper.svelte-1ih628r{max-height:100vh;max-width:100vw}.markdown-body.svelte-1ih628r{min-width:100px;max-width:900px;margin:0 auto;padding:45px;color:#e9f1f7;font-family:Muli,sans-serif}@media(max-width:767px){.markdown-body.svelte-1ih628r{max-width:75%}}</style> <noscript id=sapper-head-start></noscript><title>The Absolute Minimum Every Software Developer Must Know About Cryptography</title><noscript id=sapper-head-end></noscript> <link href=/client/21d5f7fc0374dd879b15/main.js rel=preload as=script><link href=/client/21d5f7fc0374dd879b15/blog_$slug.2.js rel=preload as=script></head> <body> <div id=sapper> <div class="svelte-lybuj1 layout"><button class="svelte-posnvr sb-toggle-button-closed">☰</button> <div class="svelte-posnvr sidebar-closed"><div class="svelte-posnvr author-wrapper"><p class="svelte-posnvr author">Louis DeLosSantos<p><div class="svelte-posnvr console-wrapper"><pre class=svelte-wc9ma6><code class=svelte-wc9ma6>❯ tree ./ldelossa 
├── hardware
├── linux
├── music
└── software
❯ <span id=cursor>▊</span></code></pre></div></div> <nav class=svelte-posnvr><div class="svelte-n868dk button-wrapper"><a href=about class="svelte-n868dk button-ref">about</a></div> <div class="svelte-n868dk button-wrapper"><a href=resume class="svelte-n868dk button-ref">resume</a></div> <div class="svelte-n868dk button-wrapper"><a href=projects class="svelte-n868dk button-ref">projects</a></div> <div class="svelte-n868dk button-wrapper"><a href=blog class="svelte-n868dk button-ref">blog</a></div></nav> <div class="svelte-posnvr icons-wrapper"><div class="svelte-13lfieo icons"><a href=https://www.linkedin.com/in/louisdelossantos/ target=_blank><img alt="linkedin icon" src=linkedin.svg class=svelte-13lfieo></a> <a href=https://github.com/ldelossa target=_blank><img alt="github icon" src=github.svg class=svelte-13lfieo></a> <a href=https://twitter.com/ldelossa_ld target=_blank><img alt="twitter icon" src=twitter.svg class=svelte-13lfieo></a></div></div></div> <div class="svelte-lybuj1 content-wrapper-full"> <div class="svelte-1ih628r blog-wrapper"><article class="svelte-1ih628r markdown-body"><h1>The Absolute Minimum Every Software Engineer Must Know About Cryptographic Authentication and Encryption</h1> <h1>Introduction</h1> <p>It's common to hear engineers muttering "cryptography is scary" or "oh no its a cert problem."</p> <p>The topic is a dense one full of maths, mailing lists, and vulnerabilities which quite literally shock the world. It's understandable how a lot of engineers put learning about the topics to another day.</p> <p>In my career I have been asked to build two different certificate signing backends for IoT purposes. These tasks provided the opportunity to work with authentication, encryption, and cryptography at a lower level then typical.</p> <p>This post will outline the bare minimum engineers should understand before working with authentication and encryption systems.</p> <h2>Part 1: Conceptual Overview</h2> <p>This section will provide a gentle introduction to authentication and encryption. These topics are to be read as a conceptual overview and not as literal implementation details.</p> <h3>Authentication and Encryption</h3> <p>Cryptography can lend itself to many utilities but as software developers our usage centers around authentication and encryption.</p> <p>Authentication is the act of identification. Cryptography can guarantee authentication and thus provide trust that the subject you are communicating with is indeed who they say they are. Authentication is implemented by cryptographic signing.</p> <p>Encryption is the act of concealing communications from unintended audiences. When a communication is encrypted it is guaranteed to be viewable only by the intended party.</p> <p>Authentication and encryption are used together to device a notion of trust in our applications and on the internet.</p> <h3>Cryptographic Signing</h3> <p>Cryptographically signing a message proves authentication in a single direction. It works like so:</p> <ul> <li>Sender: constructs a message to be sent.</li> <li>Sender: constructs a key to sign the message with.</li> <li>Sender: uses a signing algorithm to sign the bits of the message with the constructed keys.</li> <li>Sender: sends message along with signature to client.</li> <li>Receiver: receives the message and signature.</li> <li>Receiver: retrieves the sender's key.</li> <li>Receiver: uses the sender's key to sign the received message.</li> <li>Receiver: compares the sender's signature with the one computed by the receiver itself.</li> </ul> <p>If the receiver sees both signatures as equal and knows it can trust the key used to create the signature, the receiver can trust the message is from the sender.</p> <p>The various ways to securely transfer the sender's key to the receiver will be covered a bit later in the post.</p> <p>Typical signing algorithms are:</p> <ul> <li>HS256 - HMAC with SHA256</li> <li>RSA256 - RSA Signature with SHA256</li> </ul> <h3>Cryptographic Encryption</h3> <p>While similar in procedure, cryptographic encryption serves a separate purpose. It works like so:</p> <ul> <li>Sender: constructs a key</li> <li>Sender: construct a message to send</li> <li>Sender: run the message bits and the key through an encryption algorithm, producing unintelligible ciphertext.</li> <li>Sender: sends cipher text message to receiver.</li> <li>Receiver: receives the message</li> <li>Receiver: retrieves the sender's key</li> <li>Receiver: runs the message's ciphertext and the retrieved key through the same encryption algorithm, producing an intelligible message.</li> </ul> <p>In the above scenario the key is being utilized on every message to encrypt the message and conceal its contents.</p> <p>Typical encryption algorithms are:</p> <ul> <li>DES & 3DES</li> <li>RSA</li> <li>Blowfish</li> <li>AES</li> </ul> <h2>Part 2: Applied Technologies</h2> <p>Several widely used technologies apply signing and encryption in practice. We will cover the following:</p> <ul> <li>Private Key Infrastructure And x509 Certificates</li> <li>TLS (SSL)</li> <li>JSON Web Tokens / JSON Web Signatures</li> </ul> <h3>Private Key Infrastructure And x509 Certificates</h3> <p>Private key infrastructure, or PKI for short, is a grouping of technologies, protocols, and policies. This grouping can be used in tandem to ensure both authentication and encryption and securely transfer keys between parties.</p> <p>PKI is based on a private/public key model. In this model a private key is used for signing or encryption while the public key is used for verification or decryption.</p> <p>*aside: Often the terms "asymmetric" and "symmetric" encryption come up. When the same key is used to encrypt and decrypt a message, this is known as "symmetric" encryption. When a key is used to encrypt a message as a different key is used to decrypt the message, this is known as "asymmetric" encryption. Public/Private key encryption is considered "asymmetric".</p> <p>The private key is kept secret and used to sign data while the public key can verify what the private key signs. The public key can never be used to derive the private key and this is mathematically proven.</p> <p><em>aside: PKI infrastructure will typically use RSA public and private keys. We dig into this more later in the post.</em></p> <p>In our examples above the sender would sign a message with its private key, make its public key available to the receiver, and the receiver would verify the message utilizing the sender's public key.</p> <p>PKI is called an 'infrastructure' because it provides a trust policy in addition to authentication and encryption.</p> <p>In PKI the trust policy takes the form of a tree. At the root of the tree is the "root CA", where CA is short for certificate authority. The root can create one or more "intermediate CA(s)" by creating and signing their certificate with its own private key, providing authenticity that the intermediate CA was created by the root. This creates a chain of trust as I can confirm an intermediate is signed by its root by obtaining the root's public key and verifying the certificate's signature.</p> <p>The intermediate CA is then kept online while the root CA is kept offline. This is for security purposes, if the intermediate CA private keys are compromised they can be revoked and the collateral damage can be managed. If the root CA's key is compromised all certificates created by any CA in the tree must be revoked.</p> <p>A diagram can help provide a visual aide.</p> <p><img alt="pki hierarchy diagram" src=./pki_hierarchy_diagram.png></p> <p>Each node in the chain has both a private key and a certificate.</p> <p>PKI utilizes a standardized certificate model specified in <a href=https://tools.ietf.org/html/rfc2459>rfc-2459</a>.</p> <p>A certificate is an envelope containing metadata and the public key of the owner. It may be used as follows:</p> <ul> <li>Sender: Signs a message with it's private key.</li> <li>Sender: Sends message to receiver.</li> <li>Receiver: Receives message.</li> <li>Receiver: Obtains the sender's certificate.</li> <li>Receiver: Verifies the certificate's authenticity by following the certificate trust chain.</li> <li>Receiver: Extracts public key from certificate and verifies message.</li> </ul> <p>Note that it is not enough to simply extract the public key and verify the message. The receiver must verify the encountered certificate was indeed signed by the issuer's private key. This is typically performed by the receiver having a local copy of popular root and intermediate certificates, extracting the public key from the one matching the issuer of the encountered certificate, and verifying the signature.</p> <p>It is worthwhile to take a pragmatic look at setting up a root CA, intermediate, and signing client certificates. A wonderful tutorial can be found <a href=https://jamielinux.com/docs/openssl-certificate-authority/ >here</a></p> <h3>TLS</h3> <p>TLS utilizes PKI to implement encryption over HTTP also known as "HTTPS". TLS guarantees that every bit of data between two HTTP clients is encrypted and unintelligible to any other parties which may route the traffic.</p> <p>TLS is a protocol which exchanges asymmetric keys, generates symmetric keys, and uses the symmetric keys to encrypt data between parties.</p> <p>When a browser connects to an HTTPS website a handshake occurs. Within this handshake the server's certificate is verified and a set of symmetric keys are crafted. All communication on this secure channel is now encrypted and decrypted with the symmetric keys.</p> <p>The reason symmetric keys are used is for performance. Encrypting and decrypting with a private/public key can be expensive due to key size. Encryption and decryption can occur quicker with smaller symmetric keys.</p> <p>TLS also provides authentication.</p> <p>Each https server is assigned a client certificate. From our PKI diagram, client certificates are the leafs. When a user requests information from a server, the user's browser will check the server's certificate. If the browser cannot prove the certificate was created by a trusted root or intermediate CA the connection will fail.</p> <p><em>aside: if you ever had to install a certificate bundle to a server because ssl was failing you are installing a well known set of trusted root and intermediate certificates. This is used in the above verification process.</em></p> <p>With TLS comes maintenance. TLS certificates expire over time and must be kept up to date. Traditionally a server TLS certificate would be purchased from a well known root CA such as DigiTrust. Today, "let's encrypt" has paved the way for free certificates, albeit these certs expire much sooner then ones you can purchase from a trusted root ca.</p> <h3>JSON Web Tokens and JSON Web Encryption</h3> <p>JSON Web Tokens or JWT for short has become a popular form of authentication in modern web applications. When coupled with JSON Web Encryption both authentication and encryption can be utilized.</p> <p>The ubiquity of JWT and JSE is due to it's simplicity and ease of use. Both specifications use JSON to transfer a signed and optionally encrypted token between parties.</p> <p>This token can optionally contain claims, key/value information potentially useful for the receiving party along with several other "sections" which are base64 encoded and signed. The full details of generating a token can be viewed <a href=https://jwt.io/introduction/ >here</a>.</p> <p>The flow of jwt interaction follows:</p> <ul> <li>Sender: generates the header and the payload for the JWT.</li> <li>Sender: generate the signature for the JWT utilizing a key.</li> <li>Sender: places the token in an "authorization" http header.</li> <li>Receiver: parses the "authorization" header and retrieves the token.</li> <li>Receiver: retrieves the sender's key.</li> <li>Receiver: verifies the signature portion with the sender's key.</li> </ul> <p>JWT alone provides no key transfer facilities and the token's data is in plain text. However, with JSON Web Encryption (JWE) it becomes possible to piggyback off PKI and retrieve public keys via the public key infrastructure.</p> <p>More than a high level overview is further then this post would like to go. If you are interested in further details on JWT and JWE I suggest checking out the <a href=https://tools.ietf.org/html/rfc7519>JWT RFC</a> and <a href=https://tools.ietf.org/html/rfc7516>JWE RFC</a> directly.</p> <p>Understanding this post will lend itself to utilizing JWT and JWE without much difficulty, as their components build on the fundamentals.</p> <h2>Part 2: Encodings</h2> <p>The following topics will describe the ubiquitous encoding formats encountered in modern authentication and encryption applications.</p> <h3>It All Starts With ASN.1</h3> <p>ASN.1 is a language for <strong>describing</strong> encodings.</p> <p>A user of ASN.1 can write out ASN.1 data types.</p> <p>A consumer of ASN.1 definitions program how these objects will serialize to disk or a network wire. This is referred to as an "encoding" of ASN.1 types.</p> <p>For example an ASN.1 definition may describe a data structure comprised of two integer fields, an array of integers field, and a string field in a similar fashion as a structure in Go.</p> <pre class=hljs><code><span class=hljs-keyword>type</span> Obj <span class=hljs-keyword>struct</span> {
  X <span class=hljs-keyword>int</span>
  Y <span class=hljs-keyword>int</span>
  Values []<span class=hljs-keyword>int</span>
  Name <span class=hljs-keyword>string</span>
}
</code></pre> <p>Just as we can take any Go struct with public members and encode it into JSON, ASN.1 provides a common language to define structures and encode it into several forms.</p> <p>ASN.1 is heavily used in the telecommunication industry and remains popular due to its extensibility.</p> <h4>DER</h4> <p>DER specifies a set of rules for encoding ASN.1 objects into binary.</p> <p>Any objects described in ASN.1 can be encoded into DER and serialized as binary.</p> <p>Libraries will often return DER encoded keys and certificates when crafting cryptographic primitives. It can be convenient for applications to work with DER as any penalty for marshalling/unmarshalling the binary to ASCII is not present.</p> <h4>PEM</h4> <p>PEM is simply the base64 encoded DER data surrounded by a block of ASCII text. Since DER can encode several ASN.1 formats and PEM simply holds a base64 representation of this data, PEM can hold multiple ASN.1 described formats transitively.</p> <p>PEM is the encoding public keys, private keys, and certificates are typically transported in, as they are human readable and can be instantly recognized.</p> <p>A PEM private key follows:</p> <pre class=hljs><code>-----BEGIN RSA PRIVATE KEY-----
MIIEpQIBAAKCAQEA3Tz2mr7SZiAMfQyuvBjM9Oi..Z1BjP5CE/Wm/Rr500P
RK+Lh9x5eJPo5CAZ3/ANBE0sTK0ZsDGMak2m1g7..3VHqIxFTz0Ta1d+NAj
wnLe4nOb7/eEJbDPkk05ShhBrJGBKKxb8n104o/..PdzbFMIyNjJzBM2o5y
5A13wiLitEO7nco2WfyYkQzaxCw0AwzlkVHiIyC..71pSzkv6sv+4IDMbT/
XpCo8L6wTarzrywnQsh+etLD6FtTjYbbrvZ8RQM..Hg2qxraAV++HNBYmNW
s0duEdjUbJK+ZarypXI9TtnS4o1Ckj7POfljiQI..IBAFyidxtqRQyv5KrD
kbJ+q+rsJxQlaipn2M4lGuQJEfIxELFDyd3XpxP..Un/82NZNXlPmRIopXs
2T91jiLZEUKQw+n73j26adTbteuEaPGSrTZxBLR..yssO0wWomUyILqVeti
6AkL0NJAuKcucHGqWVgUIa4g1haE0ilcm6dWUDo..fd+PpzdCJf1s4NdUWK
YV2GJcutGQb+jqT5DTUqAgST7N8M28rwjK6nVMI..BUpP0xpPnuYDyPOw6x
4hBt8DZQYyduzIXBXRBKNiNdv8fum68/5klHxp6..4HRkMUL958UVeljUsT
BFQlO9UCgYEA/VqzXVzlz8K36VSTMPEhB5zBATV..PRiXtYK1YpYV4/jSUj
vvT4hP8uoYNC+BlEMi98LtnxZIh0V4rqHDsScAq..VyeSLH0loKMZgpwFEm
bEIDnEOD0nKrfT/9K9sPYgvB43wsLEtUujaYw3W..Liy0WKmB8CgYEA34xn
1QlOOhHBn9Z8qYjoDYhvcj+a89tD9eMPhesfQFw..rsfGcXIonFmWdVygbe
6Doihc+GIYIq/QP4jgMksE1ADvczJSke92ZfE2i..fitBpQERNJO0BlabfP
ALs5NssKNmLkWS2U2BHCbv4DzDXwiQB37KPOL1c..kBHfF2/htIs20d1UVL
+PK+aXKwguI6bxLGZ3of0UH+mGsSl0mkp7kYZCm..OTQtfeRqP8rDSC7DgA
kHc5ajYqh04AzNFaxjRo+M3IGICUaOdKnXd0Fda..QwfoaX4QlRTgLqb7AN
ZTzM9WbmnYoXrx17kZlT3lsCgYEAm757XI3WJVj..WoLj1+v48WyoxZpcai
uv9bT4Cj+lXRS+gdKHK+SH7J3x2CRHVS+WH/SVC..DxuybvebDoT0TkKiCj
BWQaGzCaJqZa+POHK0klvS+9ln0/6k539p95tfX..X4TCzbVG6+gJiX0ysz
Yfehn5MCgYEAkMiKuWHCsVyCab3RUf6XA9gd3qY..fCTIGtS1tR5PgFIV+G
engiVoWc/hkj8SBHZz1n1xLN7KDf8ySU06MDggB..hJ+gXJKy+gf3mF5Kmj
DtkpjGHQzPF6vOe907y5NQLvVFGXUq/FIJZxB8k..fJdHEm2M4=
-----END RSA PRIVATE KEY-----
</code></pre> <p>Because the base64 value can be several ASN.1 descriptions the PEM encoding wraps the base64 data with some header information. This is helpful for libraries which parse and decode these files.</p> <h4>PKCS8 and PKIX</h4> <p>PKCS8 and PKIX are formats specifically utilized for encoding a private key and a public key respectively. The former is part of a larger set of <a href=https://en.wikipedia.org/wiki/PKCS>PKCS protocols</a> defined by the RSA organization. The latter is defined by the Public Key Infrastructure working in <a href=https://tools.ietf.org/html/rfc5280#section-4.1>rfc-5280 section4.1</a>:</p> <pre class=hljs><code>SubjectPublicKeyInfo  ::=  SEQUENCE  {
     algorithm            AlgorithmIdentifier,
     subjectPublicKey     BIT STRING  }
</code></pre> <p>Both these formats are expressed in ASN.1 notation, therefore they can be DER encoded and subsequently PEM encoded.</p> <p>These formats support password protection utilizing symmetric keys where both DER and PEM do not.</p> <h3>RSA Keys And Certificates</h3> <p>RSA keys are often used with x.509 certificates. As a reminder certificates are used to prove authenticity.</p> <p>The certificate has a public key and enough information to prove this key is from who the receiver thinks it is.</p> <p>A certificate is yet another ASN.1 described object defined in the <a href=https://tools.ietf.org/html/rfc5280>rfc-5280</a> and can be marshalled to DER and PEM just like the others.</p> <h2>Part 3: An example</h2> <p>Generate a RSA Key Pair.</p> <pre class=hljs><code>f, err := os.Open(<span class=hljs-string>"/dev/random"</span>)
<span class=hljs-keyword>if</span> err != <span class=hljs-literal>nil</span> {
    log.Fatal(err)
}
private, err := rsa.GenerateKey(f, <span class=hljs-number>4096</span>)
</code></pre> <p>The above uses "/dev/random" as a random seed source and creates a 4096 bit key pair.</p> <p>The public key can be extracted from the private.</p> <pre class=hljs><code>public := private.Public()
</code></pre> <p>Both <code>private</code> and <code>public</code> variables hold a language specific key object with fields specific to the RSA algorithm.</p> <p>We want to transport the public key, both PKCS1 and PKIX are formats that can accomplish this. Since we covered PKIX in this post lets use that format.</p> <pre class=hljs><code>der, err := x509.MarshalPKIXPublicKey(public)
</code></pre> <p>This marshal function will take the language specific public key object, marshall it into the ASN.1 PKIX description, and then encode this ASN.1 description into binary. The <code>der</code> variable holds a byte slice containing the DER encoding of the private key.</p> <p>If the goal is to simply store a public key in a database the binary DER encoding fulfills this use case. However, if the key must transit a transport that is not byte safe such as a network or email system we must PEM encoded the byte slice.</p> <p>In order to PEM encode our DER encoded PKIX public key we need to create a PEM block.</p> <pre class=hljs><code>type Block struct {
    Type    string            // The type, taken from the preamble (i.e. "RSA PRIVATE KEY").
    Headers map[string]string // Optional headers.
    Bytes   []byte            // The decoded bytes of the contents. Typically a DER encoded ASN.1 structure.
}
</code></pre> <p>The structure defines a few fields.</p> <p><code>Type</code> is ASCII text which defines the binary data being encoded. For a PKIX public key this should be "PUBLIC KEY".</p> <p>Headers allow for further details about the binary we are encoding, we will not use this.</p> <p>Finally the <code>Bytes</code> field contains the binary data we are going to base64 encode into ASCII. Remember a PEM is simply the base64 encoded binary data with some ASCII type and header information heading and footing the results.</p> <pre class=hljs><code>block := pem.Block{
    Type:  <span class=hljs-string>"PUBLIC KEY"</span>,
    Bytes: der,
}
pem := pem.EncodeToMemory(block)
</code></pre> <p>The above defines the block and encodes our binary PKIX key into an ASCII PEM format.</p> <p>At this point we can print the pem encoded key and see a familiar sight.</p> <pre class=hljs><code>fmt.Print(<span class=hljs-keyword>string</span>(pem))
</code></pre> <pre class=hljs><code>-----BEGIN PUBLIC KEY-----
MIICCgKCAgEAsWQmmNw+gBRR2vq59w2LyUtJ/E3kKiatjGYmpTuSlrzbIiXNL3qz
xWGUhgux6UYJlEReT6eCwIfVJvVGJVRl/cL5ji3FCg+PAUqkn9BIFODx1MHWyWDe
4/nQpfNpW7NjPW90M2yYR3YVKscyupidpJS3o99Iay3KmYn1xJ6HBaFTx3WXo9xG
vqDY8uVGzcawUiTe3S2FUaKwi5SWU2bb98gzrQ1vTLej01Wh8mH6w+rrnZy5l+nz
grRqVbVwP7Q2LbcrbJGj8P3RT+3RafuP4S0Xf9X6IbNsAFYLFDarMwlB9cnVda3v
CgHuGPqwBWU9KaXT1XRhdnvqX7dBi48GFOKyiD0jULY50sxLbGHCoWno0OUHFuZ4
36kRAtTJOVTMt0yuUT9rfIfthdo8sCcQxamTmE3AFZs1/aKu8/wKJn6XfXSQjBPD
hHXi1k9v1pMIjqUPWIo6JVtuuctX6ypTq3Q8PbJ4XCybIDemA7juKG3idyruUXS+
09cCQkQ6sylVDHwmaskowcC5H5G87xdrXl8NyAkh+oq3hVBSG0lCQeDWVvsua8L5
gxHQwz9xDtXKDXkZk7ovyVGISAKBpW7o4VBnE3zkpOQGluH/QfUWjX/fiD6cazz6
msBtiBSSjM6yL+CosTSarhgd1qB0y3/ZgwDTRL+Ax2vvmiz06mfSjsUCAwEAAQ==
-----END PUBLIC KEY-----
</code></pre> <h2>Conclusion</h2> <p>A novice's view of cryptography is clouded by unfamiliar terminology and acronyms. This often leads to engineers avoiding the subject all together.</p> <p>This post makes it apparent that working with cryptography in a pragmatic sense has parallels with json or protobuf. At the end of the day, we describe a machine agnostic definition of an object (ASN.1), specify a way to encode this description (DER), and optionally modify the binary encoding to be network and email friendly (PEM).</p> <p>With this new perspective tasks dealing with certificates, ssl, authentication, and encryption should be demystified enough to tackle.</p> </article></div></div></div></div> <script>__SAPPER__={baseUrl:"",preloaded:[void 0,null,{article:{date:"2020-9-22",title:"The Absolute Minimum Every Software Developer Must Know About Cryptography",desc:"What every developer should know about crytography to make their lifes easier.",file:"absolute-minimum-cryptography",html:"\u003Ch1\u003EThe Absolute Minimum Every Software Engineer Must Know About Cryptographic Authentication and Encryption\u003C\u002Fh1\u003E\n\u003Ch1\u003EIntroduction\u003C\u002Fh1\u003E\n\u003Cp\u003EIt's common to hear engineers muttering &quot;cryptography is scary&quot; or &quot;oh no its a cert problem.&quot;\u003C\u002Fp\u003E\n\u003Cp\u003EThe topic is a dense one full of maths, mailing lists, and vulnerabilities which quite literally shock the world.\nIt's understandable how a lot of engineers put learning about the topics to another day.\u003C\u002Fp\u003E\n\u003Cp\u003EIn my career I have been asked to build two different certificate signing backends for IoT purposes.\nThese tasks provided the opportunity to work with authentication, encryption, and cryptography at a lower level then typical.\u003C\u002Fp\u003E\n\u003Cp\u003EThis post will outline the bare minimum engineers should understand before working with authentication and encryption systems.\u003C\u002Fp\u003E\n\u003Ch2\u003EPart 1: Conceptual Overview\u003C\u002Fh2\u003E\n\u003Cp\u003EThis section will provide a gentle introduction to authentication and encryption.\nThese topics are to be read as a conceptual overview and not as literal implementation details.\u003C\u002Fp\u003E\n\u003Ch3\u003EAuthentication and Encryption\u003C\u002Fh3\u003E\n\u003Cp\u003ECryptography can lend itself to many utilities but as software developers our usage centers around authentication and encryption.\u003C\u002Fp\u003E\n\u003Cp\u003EAuthentication is the act of identification.\nCryptography can guarantee authentication and thus provide trust that the subject you are communicating with is indeed who they say they are.\nAuthentication is implemented by cryptographic signing.\u003C\u002Fp\u003E\n\u003Cp\u003EEncryption is the act of concealing communications from unintended audiences.\nWhen a communication is encrypted it is guaranteed to be viewable only by the intended party.\u003C\u002Fp\u003E\n\u003Cp\u003EAuthentication and encryption are used together to device a notion of trust in our applications and on the internet.\u003C\u002Fp\u003E\n\u003Ch3\u003ECryptographic Signing\u003C\u002Fh3\u003E\n\u003Cp\u003ECryptographically signing a message proves authentication in a single direction. It works like so:\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003ESender: constructs a message to be sent.\u003C\u002Fli\u003E\n\u003Cli\u003ESender: constructs a key to sign the message with.\u003C\u002Fli\u003E\n\u003Cli\u003ESender: uses a signing algorithm to sign the bits of the message with the constructed keys.\u003C\u002Fli\u003E\n\u003Cli\u003ESender: sends message along with signature to client.\u003C\u002Fli\u003E\n\u003Cli\u003EReceiver: receives the message and signature.\u003C\u002Fli\u003E\n\u003Cli\u003EReceiver: retrieves the sender's key.\u003C\u002Fli\u003E\n\u003Cli\u003EReceiver: uses the sender's key to sign the received message.\u003C\u002Fli\u003E\n\u003Cli\u003EReceiver: compares the sender's signature with the one computed by the receiver itself.\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cp\u003EIf the receiver sees both signatures as equal and knows it can trust the key used to create the signature, the receiver can trust the message is from the sender.\u003C\u002Fp\u003E\n\u003Cp\u003EThe various ways to securely transfer the sender's key to the receiver will be covered a bit later in the post.\u003C\u002Fp\u003E\n\u003Cp\u003ETypical signing algorithms are:\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003EHS256 - HMAC with SHA256\u003C\u002Fli\u003E\n\u003Cli\u003ERSA256 - RSA Signature with SHA256\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Ch3\u003ECryptographic Encryption\u003C\u002Fh3\u003E\n\u003Cp\u003EWhile similar in procedure, cryptographic encryption serves a separate purpose. It works like so:\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003ESender: constructs a key\u003C\u002Fli\u003E\n\u003Cli\u003ESender: construct a message to send\u003C\u002Fli\u003E\n\u003Cli\u003ESender: run the message bits and the key through an encryption algorithm, producing unintelligible ciphertext.\u003C\u002Fli\u003E\n\u003Cli\u003ESender: sends cipher text message to receiver.\u003C\u002Fli\u003E\n\u003Cli\u003EReceiver: receives the message\u003C\u002Fli\u003E\n\u003Cli\u003EReceiver: retrieves the sender's key\u003C\u002Fli\u003E\n\u003Cli\u003EReceiver: runs the message's ciphertext and the retrieved key through the same encryption algorithm, producing an intelligible message.\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cp\u003EIn the above scenario the key is being utilized on every message to encrypt the message and conceal its contents.\u003C\u002Fp\u003E\n\u003Cp\u003ETypical encryption algorithms are:\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003EDES &amp; 3DES\u003C\u002Fli\u003E\n\u003Cli\u003ERSA\u003C\u002Fli\u003E\n\u003Cli\u003EBlowfish\u003C\u002Fli\u003E\n\u003Cli\u003EAES\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Ch2\u003EPart 2: Applied Technologies\u003C\u002Fh2\u003E\n\u003Cp\u003ESeveral widely used technologies apply signing and encryption in practice. We will cover the following:\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003EPrivate Key Infrastructure And x509 Certificates\u003C\u002Fli\u003E\n\u003Cli\u003ETLS (SSL)\u003C\u002Fli\u003E\n\u003Cli\u003EJSON Web Tokens \u002F JSON Web Signatures\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Ch3\u003EPrivate Key Infrastructure And x509 Certificates\u003C\u002Fh3\u003E\n\u003Cp\u003EPrivate key infrastructure, or PKI for short, is a grouping of technologies, protocols, and policies.\nThis grouping can be used in tandem to ensure both authentication and encryption and securely transfer keys between parties.\u003C\u002Fp\u003E\n\u003Cp\u003EPKI is based on a private\u002Fpublic key model.\nIn this model a private key is used for signing or encryption while the public key is used for verification or decryption.\u003C\u002Fp\u003E\n\u003Cp\u003E*aside: Often the terms &quot;asymmetric&quot; and &quot;symmetric&quot; encryption come up. When the same key is used to encrypt and decrypt a message, this is known as &quot;symmetric&quot; encryption. When a key is used to encrypt a message as a different key is used to decrypt the message, this is known as &quot;asymmetric&quot; encryption. Public\u002FPrivate key encryption is considered &quot;asymmetric&quot;.\u003C\u002Fp\u003E\n\u003Cp\u003EThe private key is kept secret and used to sign data while the public key can verify what the private key signs.\nThe public key can never be used to derive the private key and this is mathematically proven.\u003C\u002Fp\u003E\n\u003Cp\u003E\u003Cem\u003Easide: PKI infrastructure will typically use RSA public and private keys. We dig into this more later in the post.\u003C\u002Fem\u003E\u003C\u002Fp\u003E\n\u003Cp\u003EIn our examples above the sender would sign a message with its private key, make its public key available to the receiver, and the receiver would verify the message utilizing the sender's public key.\u003C\u002Fp\u003E\n\u003Cp\u003EPKI is called an 'infrastructure' because it provides a trust policy in addition to authentication and encryption.\u003C\u002Fp\u003E\n\u003Cp\u003EIn PKI the trust policy takes the form of a tree.\nAt the root of the tree is the &quot;root CA&quot;, where CA is short for certificate authority.\nThe root can create one or more &quot;intermediate CA(s)&quot; by creating and signing their certificate with its own private key, providing authenticity that the intermediate CA was created by the root.\nThis creates a chain of trust as I can confirm an intermediate is signed by its root by obtaining the root's public key and verifying the certificate's signature.\u003C\u002Fp\u003E\n\u003Cp\u003EThe intermediate CA is then kept online while the root CA is kept offline.\nThis is for security purposes, if the intermediate CA private keys are compromised they can be revoked and the collateral damage can be managed.\nIf the root CA's key is compromised all certificates created by any CA in the tree must be revoked.\u003C\u002Fp\u003E\n\u003Cp\u003EA diagram can help provide a visual aide.\u003C\u002Fp\u003E\n\u003Cp\u003E\u003Cimg src=\".\u002Fpki_hierarchy_diagram.png\" alt=\"pki hierarchy diagram\"\u003E\u003C\u002Fp\u003E\n\u003Cp\u003EEach node in the chain has both a private key and a certificate.\u003C\u002Fp\u003E\n\u003Cp\u003EPKI utilizes a standardized certificate model specified in \u003Ca href=\"https:\u002F\u002Ftools.ietf.org\u002Fhtml\u002Frfc2459\"\u003Erfc-2459\u003C\u002Fa\u003E.\u003C\u002Fp\u003E\n\u003Cp\u003EA certificate is an envelope containing metadata and the public key of the owner. It may be used as follows:\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003ESender: Signs a message with it's private key.\u003C\u002Fli\u003E\n\u003Cli\u003ESender: Sends message to receiver.\u003C\u002Fli\u003E\n\u003Cli\u003EReceiver: Receives message.\u003C\u002Fli\u003E\n\u003Cli\u003EReceiver: Obtains the sender's certificate.\u003C\u002Fli\u003E\n\u003Cli\u003EReceiver: Verifies the certificate's authenticity by following the certificate trust chain.\u003C\u002Fli\u003E\n\u003Cli\u003EReceiver: Extracts public key from certificate and verifies message.\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cp\u003ENote that it is not enough to simply extract the public key and verify the message.\nThe receiver must verify the encountered certificate was indeed signed by the issuer's private key.\nThis is typically performed by the receiver having a local copy of popular root and intermediate certificates, extracting the public key from the one matching the issuer of the encountered certificate, and verifying the signature.\u003C\u002Fp\u003E\n\u003Cp\u003EIt is worthwhile to take a pragmatic look at setting up a root CA, intermediate, and signing client certificates.\nA wonderful tutorial can be found \u003Ca href=\"https:\u002F\u002Fjamielinux.com\u002Fdocs\u002Fopenssl-certificate-authority\u002F\"\u003Ehere\u003C\u002Fa\u003E\u003C\u002Fp\u003E\n\u003Ch3\u003ETLS\u003C\u002Fh3\u003E\n\u003Cp\u003ETLS utilizes PKI to implement encryption over HTTP also known as &quot;HTTPS&quot;.\nTLS guarantees that every bit of data between two HTTP clients is encrypted and unintelligible to any other parties which may route the traffic.\u003C\u002Fp\u003E\n\u003Cp\u003ETLS is a protocol which exchanges asymmetric keys, generates symmetric keys, and uses the symmetric keys to encrypt data between parties.\u003C\u002Fp\u003E\n\u003Cp\u003EWhen a browser connects to an HTTPS website a handshake occurs.\nWithin this handshake the server's certificate is verified and a set of symmetric keys are crafted.\nAll communication on this secure channel is now encrypted and decrypted with the symmetric keys.\u003C\u002Fp\u003E\n\u003Cp\u003EThe reason symmetric keys are used is for performance.\nEncrypting and decrypting with a private\u002Fpublic key can be expensive due to key size.\nEncryption and decryption can occur quicker with smaller symmetric keys.\u003C\u002Fp\u003E\n\u003Cp\u003ETLS also provides authentication.\u003C\u002Fp\u003E\n\u003Cp\u003EEach https server is assigned a client certificate.\nFrom our PKI diagram, client certificates are the leafs.\nWhen a user requests information from a server, the user's browser will check the server's certificate.\nIf the browser cannot prove the certificate was created by a trusted root or intermediate CA the connection will fail.\u003C\u002Fp\u003E\n\u003Cp\u003E\u003Cem\u003Easide: if you ever had to install a certificate bundle to a server because ssl was failing you are installing a well known set of trusted root and intermediate certificates. This is used in the above verification process.\u003C\u002Fem\u003E\u003C\u002Fp\u003E\n\u003Cp\u003EWith TLS comes maintenance.\nTLS certificates expire over time and must be kept up to date.\nTraditionally a server TLS certificate would be purchased from a well known root CA such as DigiTrust.\nToday, &quot;let's encrypt&quot; has paved the way for free certificates, albeit these certs expire much sooner then ones you can purchase from a trusted root ca.\u003C\u002Fp\u003E\n\u003Ch3\u003EJSON Web Tokens and JSON Web Encryption\u003C\u002Fh3\u003E\n\u003Cp\u003EJSON Web Tokens or JWT for short has become a popular form of authentication in modern web applications.\nWhen coupled with JSON Web Encryption both authentication and encryption can be utilized.\u003C\u002Fp\u003E\n\u003Cp\u003EThe ubiquity of JWT and JSE is due to it's simplicity and ease of use.\nBoth specifications use JSON to transfer a signed and optionally encrypted token between parties.\u003C\u002Fp\u003E\n\u003Cp\u003EThis token can optionally contain claims, key\u002Fvalue information potentially useful for the receiving party along with several other &quot;sections&quot; which are base64 encoded and signed.\nThe full details of generating a token can be viewed \u003Ca href=\"https:\u002F\u002Fjwt.io\u002Fintroduction\u002F\"\u003Ehere\u003C\u002Fa\u003E.\u003C\u002Fp\u003E\n\u003Cp\u003EThe flow of jwt interaction follows:\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003ESender: generates the header and the payload for the JWT.\u003C\u002Fli\u003E\n\u003Cli\u003ESender: generate the signature for the JWT utilizing a key.\u003C\u002Fli\u003E\n\u003Cli\u003ESender: places the token in an &quot;authorization&quot; http header.\u003C\u002Fli\u003E\n\u003Cli\u003EReceiver: parses the &quot;authorization&quot; header and retrieves the token.\u003C\u002Fli\u003E\n\u003Cli\u003EReceiver: retrieves the sender's key.\u003C\u002Fli\u003E\n\u003Cli\u003EReceiver: verifies the signature portion with the sender's key.\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cp\u003EJWT alone provides no key transfer facilities and the token's data is in plain text.\nHowever, with JSON Web Encryption (JWE) it becomes possible to piggyback off PKI and retrieve public keys via the public key infrastructure.\u003C\u002Fp\u003E\n\u003Cp\u003EMore than a high level overview is further then this post would like to go.\nIf you are interested in further details on JWT and JWE I suggest checking out the \u003Ca href=\"https:\u002F\u002Ftools.ietf.org\u002Fhtml\u002Frfc7519\"\u003EJWT RFC\u003C\u002Fa\u003E and \u003Ca href=\"https:\u002F\u002Ftools.ietf.org\u002Fhtml\u002Frfc7516\"\u003EJWE RFC\u003C\u002Fa\u003E directly.\u003C\u002Fp\u003E\n\u003Cp\u003EUnderstanding this post will lend itself to utilizing JWT and JWE without much difficulty, as their components build on the fundamentals.\u003C\u002Fp\u003E\n\u003Ch2\u003EPart 2: Encodings\u003C\u002Fh2\u003E\n\u003Cp\u003EThe following topics will describe the ubiquitous encoding formats encountered in modern authentication and encryption applications.\u003C\u002Fp\u003E\n\u003Ch3\u003EIt All Starts With ASN.1\u003C\u002Fh3\u003E\n\u003Cp\u003EASN.1 is a language for \u003Cstrong\u003Edescribing\u003C\u002Fstrong\u003E encodings.\u003C\u002Fp\u003E\n\u003Cp\u003EA user of ASN.1 can write out ASN.1 data types.\u003C\u002Fp\u003E\n\u003Cp\u003EA consumer of ASN.1 definitions program how these objects will serialize to disk or a network wire.\nThis is referred to as an &quot;encoding&quot; of ASN.1 types.\u003C\u002Fp\u003E\n\u003Cp\u003EFor example an ASN.1 definition may describe a data structure comprised of two integer fields, an array of integers field, and a string field in a similar fashion as a structure in Go.\u003C\u002Fp\u003E\n\u003Cpre class=\"hljs\"\u003E\u003Ccode\u003E\u003Cspan class=\"hljs-keyword\"\u003Etype\u003C\u002Fspan\u003E Obj \u003Cspan class=\"hljs-keyword\"\u003Estruct\u003C\u002Fspan\u003E {\n  X \u003Cspan class=\"hljs-keyword\"\u003Eint\u003C\u002Fspan\u003E\n  Y \u003Cspan class=\"hljs-keyword\"\u003Eint\u003C\u002Fspan\u003E\n  Values []\u003Cspan class=\"hljs-keyword\"\u003Eint\u003C\u002Fspan\u003E\n  Name \u003Cspan class=\"hljs-keyword\"\u003Estring\u003C\u002Fspan\u003E\n}\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003EJust as we can take any Go struct with public members and encode it into JSON, ASN.1 provides a common language to define structures and encode it into several forms.\u003C\u002Fp\u003E\n\u003Cp\u003EASN.1 is heavily used in the telecommunication industry and remains popular due to its extensibility.\u003C\u002Fp\u003E\n\u003Ch4\u003EDER\u003C\u002Fh4\u003E\n\u003Cp\u003EDER specifies a set of rules for encoding ASN.1 objects into binary.\u003C\u002Fp\u003E\n\u003Cp\u003EAny objects described in ASN.1 can be encoded into DER and serialized as binary.\u003C\u002Fp\u003E\n\u003Cp\u003ELibraries will often return DER encoded keys and certificates when crafting cryptographic primitives.\nIt can be convenient for applications to work with DER as any penalty for marshalling\u002Funmarshalling the binary to ASCII is not present.\u003C\u002Fp\u003E\n\u003Ch4\u003EPEM\u003C\u002Fh4\u003E\n\u003Cp\u003EPEM is simply the base64 encoded DER data surrounded by a block of ASCII text.\nSince DER can encode several ASN.1 formats and PEM simply holds a base64 representation of this data, PEM can hold multiple ASN.1 described formats transitively.\u003C\u002Fp\u003E\n\u003Cp\u003EPEM is the encoding public keys, private keys, and certificates are typically transported in, as they are human readable and can be instantly recognized.\u003C\u002Fp\u003E\n\u003Cp\u003EA PEM private key follows:\u003C\u002Fp\u003E\n\u003Cpre class=\"hljs\"\u003E\u003Ccode\u003E-----BEGIN RSA PRIVATE KEY-----\nMIIEpQIBAAKCAQEA3Tz2mr7SZiAMfQyuvBjM9Oi..Z1BjP5CE\u002FWm\u002FRr500P\nRK+Lh9x5eJPo5CAZ3\u002FANBE0sTK0ZsDGMak2m1g7..3VHqIxFTz0Ta1d+NAj\nwnLe4nOb7\u002FeEJbDPkk05ShhBrJGBKKxb8n104o\u002F..PdzbFMIyNjJzBM2o5y\n5A13wiLitEO7nco2WfyYkQzaxCw0AwzlkVHiIyC..71pSzkv6sv+4IDMbT\u002F\nXpCo8L6wTarzrywnQsh+etLD6FtTjYbbrvZ8RQM..Hg2qxraAV++HNBYmNW\ns0duEdjUbJK+ZarypXI9TtnS4o1Ckj7POfljiQI..IBAFyidxtqRQyv5KrD\nkbJ+q+rsJxQlaipn2M4lGuQJEfIxELFDyd3XpxP..Un\u002F82NZNXlPmRIopXs\n2T91jiLZEUKQw+n73j26adTbteuEaPGSrTZxBLR..yssO0wWomUyILqVeti\n6AkL0NJAuKcucHGqWVgUIa4g1haE0ilcm6dWUDo..fd+PpzdCJf1s4NdUWK\nYV2GJcutGQb+jqT5DTUqAgST7N8M28rwjK6nVMI..BUpP0xpPnuYDyPOw6x\n4hBt8DZQYyduzIXBXRBKNiNdv8fum68\u002F5klHxp6..4HRkMUL958UVeljUsT\nBFQlO9UCgYEA\u002FVqzXVzlz8K36VSTMPEhB5zBATV..PRiXtYK1YpYV4\u002FjSUj\nvvT4hP8uoYNC+BlEMi98LtnxZIh0V4rqHDsScAq..VyeSLH0loKMZgpwFEm\nbEIDnEOD0nKrfT\u002F9K9sPYgvB43wsLEtUujaYw3W..Liy0WKmB8CgYEA34xn\n1QlOOhHBn9Z8qYjoDYhvcj+a89tD9eMPhesfQFw..rsfGcXIonFmWdVygbe\n6Doihc+GIYIq\u002FQP4jgMksE1ADvczJSke92ZfE2i..fitBpQERNJO0BlabfP\nALs5NssKNmLkWS2U2BHCbv4DzDXwiQB37KPOL1c..kBHfF2\u002FhtIs20d1UVL\n+PK+aXKwguI6bxLGZ3of0UH+mGsSl0mkp7kYZCm..OTQtfeRqP8rDSC7DgA\nkHc5ajYqh04AzNFaxjRo+M3IGICUaOdKnXd0Fda..QwfoaX4QlRTgLqb7AN\nZTzM9WbmnYoXrx17kZlT3lsCgYEAm757XI3WJVj..WoLj1+v48WyoxZpcai\nuv9bT4Cj+lXRS+gdKHK+SH7J3x2CRHVS+WH\u002FSVC..DxuybvebDoT0TkKiCj\nBWQaGzCaJqZa+POHK0klvS+9ln0\u002F6k539p95tfX..X4TCzbVG6+gJiX0ysz\nYfehn5MCgYEAkMiKuWHCsVyCab3RUf6XA9gd3qY..fCTIGtS1tR5PgFIV+G\nengiVoWc\u002Fhkj8SBHZz1n1xLN7KDf8ySU06MDggB..hJ+gXJKy+gf3mF5Kmj\nDtkpjGHQzPF6vOe907y5NQLvVFGXUq\u002FFIJZxB8k..fJdHEm2M4=\n-----END RSA PRIVATE KEY-----\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003EBecause the base64 value can be several ASN.1 descriptions the PEM encoding wraps the base64 data with some header information.\nThis is helpful for libraries which parse and decode these files.\u003C\u002Fp\u003E\n\u003Ch4\u003EPKCS8 and PKIX\u003C\u002Fh4\u003E\n\u003Cp\u003EPKCS8 and PKIX are formats specifically utilized for encoding a private key and a public key respectively.\nThe former is part of a larger set of \u003Ca href=\"https:\u002F\u002Fen.wikipedia.org\u002Fwiki\u002FPKCS\"\u003EPKCS protocols\u003C\u002Fa\u003E defined by the RSA organization.\nThe latter is defined by the Public Key Infrastructure working in \u003Ca href=\"https:\u002F\u002Ftools.ietf.org\u002Fhtml\u002Frfc5280#section-4.1\"\u003Erfc-5280 section4.1\u003C\u002Fa\u003E:\u003C\u002Fp\u003E\n\u003Cpre class=\"hljs\"\u003E\u003Ccode\u003ESubjectPublicKeyInfo  ::=  SEQUENCE  {\n     algorithm            AlgorithmIdentifier,\n     subjectPublicKey     BIT STRING  }\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003EBoth these formats are expressed in ASN.1 notation, therefore they can be DER encoded and subsequently PEM encoded.\u003C\u002Fp\u003E\n\u003Cp\u003EThese formats support password protection utilizing symmetric keys where both DER and PEM do not.\u003C\u002Fp\u003E\n\u003Ch3\u003ERSA Keys And Certificates\u003C\u002Fh3\u003E\n\u003Cp\u003ERSA keys are often used with x.509 certificates. As a reminder certificates are used to prove authenticity.\u003C\u002Fp\u003E\n\u003Cp\u003EThe certificate has a public key and enough information to prove this key is from who the receiver thinks it is.\u003C\u002Fp\u003E\n\u003Cp\u003EA certificate is yet another ASN.1 described object defined in the \u003Ca href=\"https:\u002F\u002Ftools.ietf.org\u002Fhtml\u002Frfc5280\"\u003Erfc-5280\u003C\u002Fa\u003E and can be marshalled to DER and PEM just like the others.\u003C\u002Fp\u003E\n\u003Ch2\u003EPart 3: An example\u003C\u002Fh2\u003E\n\u003Cp\u003EGenerate a RSA Key Pair.\u003C\u002Fp\u003E\n\u003Cpre class=\"hljs\"\u003E\u003Ccode\u003Ef, err := os.Open(\u003Cspan class=\"hljs-string\"\u003E&quot;\u002Fdev\u002Frandom&quot;\u003C\u002Fspan\u003E)\n\u003Cspan class=\"hljs-keyword\"\u003Eif\u003C\u002Fspan\u003E err != \u003Cspan class=\"hljs-literal\"\u003Enil\u003C\u002Fspan\u003E {\n    log.Fatal(err)\n}\nprivate, err := rsa.GenerateKey(f, \u003Cspan class=\"hljs-number\"\u003E4096\u003C\u002Fspan\u003E)\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003EThe above uses &quot;\u002Fdev\u002Frandom&quot; as a random seed source and creates a 4096 bit key pair.\u003C\u002Fp\u003E\n\u003Cp\u003EThe public key can be extracted from the private.\u003C\u002Fp\u003E\n\u003Cpre class=\"hljs\"\u003E\u003Ccode\u003Epublic := private.Public()\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003EBoth \u003Ccode\u003Eprivate\u003C\u002Fcode\u003E and \u003Ccode\u003Epublic\u003C\u002Fcode\u003E variables hold a language specific key object with fields specific to the RSA algorithm.\u003C\u002Fp\u003E\n\u003Cp\u003EWe want to transport the public key, both PKCS1 and PKIX are formats that can accomplish this. Since we covered PKIX in this post lets use that format.\u003C\u002Fp\u003E\n\u003Cpre class=\"hljs\"\u003E\u003Ccode\u003Eder, err := x509.MarshalPKIXPublicKey(public)\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003EThis marshal function will take the language specific public key object, marshall it into the ASN.1 PKIX description, and then encode this ASN.1 description into binary.\nThe \u003Ccode\u003Eder\u003C\u002Fcode\u003E variable holds a byte slice containing the DER encoding of the private key.\u003C\u002Fp\u003E\n\u003Cp\u003EIf the goal is to simply store a public key in a database the binary DER encoding fulfills this use case.\nHowever, if the key must transit a transport that is not byte safe such as a network or email system we must PEM encoded the byte slice.\u003C\u002Fp\u003E\n\u003Cp\u003EIn order to PEM encode our DER encoded PKIX public key we need to create a PEM block.\u003C\u002Fp\u003E\n\u003Cpre class=\"hljs\"\u003E\u003Ccode\u003Etype Block struct {\n    Type    string            \u002F\u002F The type, taken from the preamble (i.e. &quot;RSA PRIVATE KEY&quot;).\n    Headers map[string]string \u002F\u002F Optional headers.\n    Bytes   []byte            \u002F\u002F The decoded bytes of the contents. Typically a DER encoded ASN.1 structure.\n}\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003EThe structure defines a few fields.\u003C\u002Fp\u003E\n\u003Cp\u003E\u003Ccode\u003EType\u003C\u002Fcode\u003E is ASCII text which defines the binary data being encoded.\nFor a PKIX public key this should be &quot;PUBLIC KEY&quot;.\u003C\u002Fp\u003E\n\u003Cp\u003EHeaders allow for further details about the binary we are encoding, we will not use this.\u003C\u002Fp\u003E\n\u003Cp\u003EFinally the \u003Ccode\u003EBytes\u003C\u002Fcode\u003E field contains the binary data we are going to base64 encode into ASCII.\nRemember a PEM is simply the base64 encoded binary data with some ASCII type and header information heading and footing the results.\u003C\u002Fp\u003E\n\u003Cpre class=\"hljs\"\u003E\u003Ccode\u003Eblock := pem.Block{\n    Type:  \u003Cspan class=\"hljs-string\"\u003E&quot;PUBLIC KEY&quot;\u003C\u002Fspan\u003E,\n    Bytes: der,\n}\npem := pem.EncodeToMemory(block)\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003EThe above defines the block and encodes our binary PKIX key into an ASCII PEM format.\u003C\u002Fp\u003E\n\u003Cp\u003EAt this point we can print the pem encoded key and see a familiar sight.\u003C\u002Fp\u003E\n\u003Cpre class=\"hljs\"\u003E\u003Ccode\u003Efmt.Print(\u003Cspan class=\"hljs-keyword\"\u003Estring\u003C\u002Fspan\u003E(pem))\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cpre class=\"hljs\"\u003E\u003Ccode\u003E-----BEGIN PUBLIC KEY-----\nMIICCgKCAgEAsWQmmNw+gBRR2vq59w2LyUtJ\u002FE3kKiatjGYmpTuSlrzbIiXNL3qz\nxWGUhgux6UYJlEReT6eCwIfVJvVGJVRl\u002FcL5ji3FCg+PAUqkn9BIFODx1MHWyWDe\n4\u002FnQpfNpW7NjPW90M2yYR3YVKscyupidpJS3o99Iay3KmYn1xJ6HBaFTx3WXo9xG\nvqDY8uVGzcawUiTe3S2FUaKwi5SWU2bb98gzrQ1vTLej01Wh8mH6w+rrnZy5l+nz\ngrRqVbVwP7Q2LbcrbJGj8P3RT+3RafuP4S0Xf9X6IbNsAFYLFDarMwlB9cnVda3v\nCgHuGPqwBWU9KaXT1XRhdnvqX7dBi48GFOKyiD0jULY50sxLbGHCoWno0OUHFuZ4\n36kRAtTJOVTMt0yuUT9rfIfthdo8sCcQxamTmE3AFZs1\u002FaKu8\u002FwKJn6XfXSQjBPD\nhHXi1k9v1pMIjqUPWIo6JVtuuctX6ypTq3Q8PbJ4XCybIDemA7juKG3idyruUXS+\n09cCQkQ6sylVDHwmaskowcC5H5G87xdrXl8NyAkh+oq3hVBSG0lCQeDWVvsua8L5\ngxHQwz9xDtXKDXkZk7ovyVGISAKBpW7o4VBnE3zkpOQGluH\u002FQfUWjX\u002FfiD6cazz6\nmsBtiBSSjM6yL+CosTSarhgd1qB0y3\u002FZgwDTRL+Ax2vvmiz06mfSjsUCAwEAAQ==\n-----END PUBLIC KEY-----\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Ch2\u003EConclusion\u003C\u002Fh2\u003E\n\u003Cp\u003EA novice's view of cryptography is clouded by unfamiliar terminology and acronyms.\nThis often leads to engineers avoiding the subject all together.\u003C\u002Fp\u003E\n\u003Cp\u003EThis post makes it apparent that working with cryptography in a pragmatic sense has parallels with json or protobuf.\nAt the end of the day, we describe a machine agnostic definition of an object (ASN.1), specify a way to encode this description (DER), and optionally modify the binary encoding to be network and email friendly (PEM).\u003C\u002Fp\u003E\n\u003Cp\u003EWith this new perspective tasks dealing with certificates, ssl, authentication, and encryption should be demystified enough to tackle.\u003C\u002Fp\u003E\n"}}]};if('serviceWorker' in navigator)navigator.serviceWorker.register('/service-worker.js');</script><script src=/client/21d5f7fc0374dd879b15/main.js></script> 